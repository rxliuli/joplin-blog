<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-fc36d5e7eddc44b3a35c68f52e2b7033" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/03/fc36d5e7eddc44b3a35c68f52e2b7033/" class="article-date">
  <time class="dt-published" datetime="2020-09-03T02:58:12.000Z" itemprop="datePublished">2020-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/03/fc36d5e7eddc44b3a35c68f52e2b7033/">使用 rollup 打包 react 库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>其实一般用 tsc 编译一下就行了，但如果想要更加强大的功能，例如打包成一个单文件、多种格式、或者包含 css 时，就需要使用 rollup 来处理了。</p>
<ul>
<li>打包</li>
<li>处理 ts</li>
<li>处理 css</li>
<li>压缩</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>package.json</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;pub&quot;</span>: <span class="string">&quot;yarn build &amp;&amp; lerna bootstrap&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rollup -c rollup.config.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span>: <span class="string">&quot;^16.9.48&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;moment&quot;</span>: <span class="string">&quot;^2.27.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rollup&quot;</span>: <span class="string">&quot;^2.26.9&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rollup-plugin-babel&quot;</span>: <span class="string">&quot;^4.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rollup-plugin-postcss&quot;</span>: <span class="string">&quot;^3.1.8&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rollup-plugin-terser&quot;</span>: <span class="string">&quot;^7.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rollup-plugin-typescript2&quot;</span>: <span class="string">&quot;^0.27.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;3.8.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rollup.config.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-babel&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-typescript2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> pkg <span class="keyword">from</span> <span class="string">&quot;./package.json&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; terser &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-terser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> postcss <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-postcss&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  input: resolve(__dirname, <span class="string">&quot;./src/index.ts&quot;</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包名称</span></span><br><span class="line">    name: pkg.name,</span><br><span class="line">    <span class="built_in">exports</span>: <span class="string">&quot;named&quot;</span>,</span><br><span class="line">    file: resolve(__dirname, <span class="string">&quot;./dist/index.js&quot;</span>),</span><br><span class="line">    format: <span class="string">&quot;es&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  external: [</span><br><span class="line">    ...Object.keys(pkg.dependencies || &#123;&#125;),</span><br><span class="line">    ...Object.keys(pkg.peerDependencies || &#123;&#125;),</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    babel(&#123;</span><br><span class="line">      exclude: <span class="string">&quot;node_modules/**&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    typescript(&#123;</span><br><span class="line">      typescript: <span class="built_in">require</span>(<span class="string">&quot;typescript&quot;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    postcss(&#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      extract: <span class="literal">true</span>,</span><br><span class="line">      minimize: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    terser(), <span class="comment">// minifies generated bundles</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/03/fc36d5e7eddc44b3a35c68f52e2b7033/" data-id="ckmcqox5c00ab0kuv00b02w9b" data-title="使用 rollup 打包 react 库" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-46a28ca74c22482d832b7d15ea2e1ec3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/02/46a28ca74c22482d832b7d15ea2e1ec3/" class="article-date">
  <time class="dt-published" datetime="2020-08-01T21:59:08.000Z" itemprop="datePublished">2020-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/02/46a28ca74c22482d832b7d15ea2e1ec3/">使用 React Context 结合 EventEmitter</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>EventEmitter 很适合在不修改组件状态结构的情况下进行组件通信，然而它的生命周期不受 react 管理，需要手动添加/清理监听事件很麻烦。而且，如果一个 EventEmitter 没有使用就被初始化也会有点麻烦。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>所以使用 react context 结合 event emitter 的目的便是</p>
<ul>
<li>添加高阶组件，通过 react context 为所有子组件注入 em 对象</li>
<li>添加自定义 hooks，从 react context 获取 emitter 对象，并暴露出合适的函数。</li>
<li>自动清理 emitter 对象和 emitter listener。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现基本的-EventEmitter"><a href="#实现基本的-EventEmitter" class="headerlink" title="实现基本的 EventEmitter"></a>实现基本的 EventEmitter</h3><p>首先，实现一个基本的 EventEmitter，这里之前吾辈曾经就有 <a target="_blank" rel="noopener" href="https://github.com/rxliuli/rx-util/blob/master/src/module/event/EventEmitter.ts">实现过</a>，所以直接拿过来了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventType = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> BaseEvents = Record&lt;EventType, <span class="built_in">any</span>[]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件总线</span></span><br><span class="line"><span class="comment"> * 实际上就是发布订阅模式的一种简单实现</span></span><br><span class="line"><span class="comment"> * 类型定义受到 &#123;<span class="doctag">@link </span>https://github.com/andywer/typed-emitter/blob/master/index.d.ts&#125; 的启发，不过只需要声明参数就好了，而不需要返回值（应该是 &#123;<span class="doctag">@code </span>void&#125;）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span>&lt;<span class="title">Events</span> <span class="keyword">extends</span> <span class="title">BaseEvents</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> events = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;keyof Events, <span class="built_in">Function</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加一个事件监听程序</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>type 监听类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>callback 处理回调</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;@code this&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  add&lt;E <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: E, <span class="attr">callback</span>: <span class="function">(<span class="params">...args: Events[E]</span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="built_in">this</span>.events.get(<span class="keyword">type</span>) || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    <span class="built_in">this</span>.events.set(<span class="keyword">type</span>, callbacks);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除一个事件监听程序</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>type 监听类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>callback 处理回调</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;@code this&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  remove&lt;E <span class="keyword">extends</span> keyof Events&gt;(</span><br><span class="line">    <span class="keyword">type</span>: E,</span><br><span class="line">    callback: <span class="function">(<span class="params">...args: Events[E]</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="built_in">this</span>.events.get(<span class="keyword">type</span>) || [];</span><br><span class="line">    <span class="built_in">this</span>.events.set(</span><br><span class="line">      <span class="keyword">type</span>,</span><br><span class="line">      callbacks.filter(<span class="function">(<span class="params">fn: <span class="built_in">any</span></span>) =&gt;</span> fn !== callback)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除一类事件监听程序</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>type 监听类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;@code this&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  removeByType&lt;E <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: E) &#123;</span><br><span class="line">    <span class="built_in">this</span>.events.delete(<span class="keyword">type</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触发一类事件监听程序</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>type 监听类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>args 处理回调需要的参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;@code this&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emit&lt;E <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: E, ...args: Events[E]) &#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="built_in">this</span>.events.get(<span class="keyword">type</span>) || [];</span><br><span class="line">    callbacks.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">      fn(...args);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取一类事件监听程序</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>type 监听类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>一个只读的数组，如果找不到，则返回空数组 &#123;<span class="doctag">@code </span>[]&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  listeners&lt;E <span class="keyword">extends</span> keyof Events&gt;(<span class="keyword">type</span>: E) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(<span class="built_in">this</span>.events.get(<span class="keyword">type</span>) || []);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结合-context-实现一个包裹组件"><a href="#结合-context-实现一个包裹组件" class="headerlink" title="结合 context 实现一个包裹组件"></a>结合 context 实现一个包裹组件</h3><p>包裹组件的目的是为了能直接提供一个包裹组件，以及提供 provider 的默认值，不需要使用者直接接触 emitter 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line">import &#123; createContext, PropsWithChildren &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; BaseEvents, EventEmitter &#125; from &quot;.&#x2F;util&#x2F;EventEmitter&quot;;</span><br><span class="line"></span><br><span class="line">export const EventEmitterContext &#x3D; createContext&lt;EventEmitter&lt;any&gt;&gt;(</span><br><span class="line">  null as any</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">export function EventEmitterRC&lt;T extends BaseEvents&gt;(</span><br><span class="line">  props: PropsWithChildren&lt;&#123; value: EventEmitter&lt;T&gt; &#125;&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;EventEmitterContext.Provider value&#x3D;&#123;props.value&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;EventEmitterContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-hooks-暴露-emitter-api"><a href="#使用-hooks-暴露-emitter-api" class="headerlink" title="使用 hooks 暴露 emitter api"></a>使用 hooks 暴露 emitter api</h3><p>我们主要需要暴露的 API 只有三个</p>
<ul>
<li><code>useListener</code>: 添加监听器，使用 hooks 是为了能在组件卸载时自动清理监听函数</li>
<li><code>emit</code>: 触发监听器，直接调用即可</li>
<li><code>emitter</code>: 在当前组件树生效的 emitter 对象</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  DependencyList,</span><br><span class="line">  useCallback,</span><br><span class="line">  useContext,</span><br><span class="line">  useEffect,</span><br><span class="line">  useMemo,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; EventEmitterContext &#125; <span class="keyword">from</span> <span class="string">&quot;../EventEmitterRC&quot;</span>;</span><br><span class="line"><span class="comment">// noinspection ES6PreferShortImport</span></span><br><span class="line"><span class="keyword">import</span> &#123; BaseEvents, EventEmitter &#125; <span class="keyword">from</span> <span class="string">&quot;../util/EventEmitter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEmit</span>&lt;<span class="title">Events</span> <span class="title">extends</span> <span class="title">BaseEvents</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> em = useContext(EventEmitterContext);</span><br><span class="line">  <span class="keyword">return</span> useCallback(</span><br><span class="line">    &lt;E <span class="keyword">extends</span> keyof Events&gt;<span class="function">(<span class="params"><span class="keyword">type</span>: E, ...args: Events[E]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;emitter emit: &quot;</span>, <span class="keyword">type</span>, args);</span><br><span class="line">      em.emit(<span class="keyword">type</span>, ...args);</span><br><span class="line">    &#125;,</span><br><span class="line">    [em]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEventEmitter</span>&lt;<span class="title">Events</span> <span class="title">extends</span> <span class="title">BaseEvents</span>&gt;(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emit = useEmit&lt;Events&gt;();</span><br><span class="line">  <span class="comment">// 这里使用 useMemo 产生的 emitter 对象的原因是在当前组件树 emitter 仅初始化一次</span></span><br><span class="line">  <span class="keyword">const</span> emitter = useMemo(<span class="function">() =&gt;</span> <span class="keyword">new</span> EventEmitter&lt;Events&gt;(), []);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    useListener: <span class="xml"><span class="tag">&lt;<span class="name">E</span> <span class="attr">extends</span> <span class="attr">keyof</span> <span class="attr">Events</span>&gt;</span>(</span></span><br><span class="line"><span class="xml">      type: E,</span></span><br><span class="line"><span class="xml">      listener: (...args: Events[E]) =&gt; void,</span></span><br><span class="line"><span class="xml">      deps: DependencyList = []</span></span><br><span class="line"><span class="xml">    ) =&gt; &#123;</span></span><br><span class="line"><span class="xml">      const em = useContext(EventEmitterContext);</span></span><br><span class="line"><span class="xml">      useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">        console.log(&quot;emitter add: &quot;, type, listener.name);</span></span><br><span class="line"><span class="xml">        em.add(type, listener);</span></span><br><span class="line"><span class="xml">        return () =&gt; &#123;</span></span><br><span class="line"><span class="xml">          console.log(&quot;emitter remove: &quot;, type, listener.name);</span></span><br><span class="line"><span class="xml">          em.remove(type, listener);</span></span><br><span class="line"><span class="xml">        &#125;;</span></span><br><span class="line"><span class="xml">        // eslint-disable-next-line react-hooks/exhaustive-deps</span></span><br><span class="line"><span class="xml">      &#125;, [listener, type, ...deps]);</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    emit,</span></span><br><span class="line"><span class="xml">    emitter,</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来非常简单，在需要使用的 emitter hooks 的组件外部包裹一个 <code>EventEmitterRC</code> 组件，然后就可以使用 <code>useEventEmitter</code> 了。</p>
<p>下面是一个简单的 Todo 示例，使用 emitter 实现了 todo 表单 与 todo 列表之间的通信。</p>
<p>目录结构如下</p>
<ul>
<li><code>todo</code><ul>
<li><code>component</code><ul>
<li><code>TodoForm.tsx</code></li>
<li><code>TodoList.tsx</code></li>
</ul>
</li>
<li><code>modal</code><ul>
<li><code>TodoEntity.ts</code></li>
<li><code>TodoEvents.ts</code></li>
</ul>
</li>
<li><code>Todo.tsx</code></li>
</ul>
</li>
</ul>
<p>Todo 父组件，使用 <code>EventEmitterRC</code> 包裹子组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Todo: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; emitter &#125; &#x3D; useEventEmitter();</span><br><span class="line">  return (</span><br><span class="line">    &lt;EventEmitterRC value&#x3D;&#123;emitter&#125;&gt;</span><br><span class="line">      &lt;TodoForm &#x2F;&gt;</span><br><span class="line">      &lt;TodoList &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;EventEmitterRC&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在表单组件中使用 <code>useEventEmitter</code> hooks 获得 <code>emit</code> 方法，然后在添加 todo 时触发它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const TodoForm: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; emit &#125; &#x3D; useEventEmitter&lt;TodoEvents&gt;();</span><br><span class="line"></span><br><span class="line">  const [title, setTitle] &#x3D; useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  function handleAddTodo(e: FormEvent&lt;HTMLFormElement&gt;) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    emit(&quot;addTodo&quot;, &#123;</span><br><span class="line">      title,</span><br><span class="line">    &#125;);</span><br><span class="line">    setTitle(&quot;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;handleAddTodo&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;label htmlFor&#x3D;&#123;&quot;title&quot;&#125;&gt;标题：&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value&#x3D;&#123;title&#125;</span><br><span class="line">          onChange&#x3D;&#123;(e) &#x3D;&gt; setTitle(e.target.value)&#125;</span><br><span class="line">          id&#x3D;&#123;&quot;title&quot;&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">        &lt;button type&#x3D;&#123;&quot;submit&quot;&#125;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在列表组件中使用 <code>useEventEmitter</code> hooks 获得 <code>useListener</code> hooks，然后监听添加 todo 的事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const TodoList: React.FC&lt;PropsType&gt; &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [list, setList] &#x3D; useState&lt;TodoEntity[]&gt;([]);</span><br><span class="line">  const &#123; useListener &#125; &#x3D; useEventEmitter&lt;TodoEvents&gt;();</span><br><span class="line">  useListener(</span><br><span class="line">    &quot;addTodo&quot;,</span><br><span class="line">    (todo) &#x3D;&gt; &#123;</span><br><span class="line">      setList([...list, todo]);</span><br><span class="line">    &#125;,</span><br><span class="line">    [list]</span><br><span class="line">  );</span><br><span class="line">  const em &#x3D; &#123; useListener &#125;;</span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;em: &quot;, em);</span><br><span class="line">  &#125;, [em]);</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;list.map((todo, i) &#x3D;&gt; (</span><br><span class="line">        &lt;li key&#x3D;&#123;i&#125;&gt;&#123;todo.title&#125;&lt;&#x2F;li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是一些 TypeScript 类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> TodoEntity &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BaseEvents &#125; <span class="keyword">from</span> <span class="string">&quot;../../../components/emitter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TodoEntity &#125; <span class="keyword">from</span> <span class="string">&quot;./TodoEntity&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> TodoEvents <span class="keyword">extends</span> BaseEvents &#123;</span><br><span class="line">  addTodo: [entity: TodoEntity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@dominikdosoudil/building-event-emitter-using-react-hooks-650f94a057ea">Building event emitter using react hooks</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/events.html">NodeJS EventEmitter API</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/02/46a28ca74c22482d832b7d15ea2e1ec3/" data-id="ckmcqox36003c0kuvfzpac048" data-title="使用 React Context 结合 EventEmitter" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-a4ea45dd6ba445e1b307ef4e1fd3233e" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/08/02/a4ea45dd6ba445e1b307ef4e1fd3233e/" class="article-date">
  <time class="dt-published" datetime="2020-08-01T18:43:40.000Z" itemprop="datePublished">2020-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/08/02/a4ea45dd6ba445e1b307ef4e1fd3233e/">关于前端组件通信的一些理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p>吾辈同时是 vue/react 的使用者。</p>
</blockquote>
<p>在使用现代前端框架时，我们经常要要面对的问题之一就是组件之间的通信，目前我们有着很多选择，包括但不限于以下这些。</p>
<ul>
<li><code>Super Component Props</code>: 将状态或操作放在父组件，然后传递到子组件。该特性在 vue/react 都存在</li>
<li><code>Context/Provider Pattern</code>: 将状态放在父组件，然后所有的子组件都可以获取到。例如 react 中的 context 或 vue 中的 <code>provide/inject</code></li>
<li><code>Global State</code>: 全局状态管理器。包含 redux/vuex/mobx/xstate 等一系列状态管理器。</li>
<li><code>EventEmitter</code>: 全局事件触发器。包含 nodejs 和一些第三方实现。</li>
</ul>
<p>然而，有了如此多的解决方案，到底该在那些场景下使用那些解决方案呢？</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>首先，我们将以上组件通信的解决方案分为两类</p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>是否在 react 生命周期中</th>
</tr>
</thead>
<tbody><tr>
<td><code>Super Component Props</code></td>
<td>√</td>
</tr>
<tr>
<td><code>Context/Provider Pattern</code></td>
<td>√</td>
</tr>
<tr>
<td><code>Global Store</code></td>
<td>×</td>
</tr>
<tr>
<td><code>EventEmitter</code></td>
<td>×</td>
</tr>
</tbody></table>
<p>选择树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">start[开始选择]</span><br><span class="line">isSimpleProps&#123;是否为简单的父子组件&#125;</span><br><span class="line">isComponentInnerUse&#123;是否仅在组件内部使用&#125;</span><br><span class="line">isUseNotice&#123;是否只需要通知而非状态共享&#125;</span><br><span class="line">favoriteStyle&#123;喜欢的风格&#125;</span><br><span class="line"></span><br><span class="line">start --&gt; isSimpleProps</span><br><span class="line">isSimpleProps --&gt; |是| props</span><br><span class="line">isSimpleProps --&gt; |否| isComponentInnerUse</span><br><span class="line">isComponentInnerUse --&gt; |是| context&#x2F;provider</span><br><span class="line">isComponentInnerUse --&gt; |否| isUseNotice</span><br><span class="line">isUseNotice --&gt; |是| emitter</span><br><span class="line">isUseNotice --&gt; |否| favoriteStyle</span><br><span class="line">favoriteStyle --&gt; |可变| mobx_跨框架</span><br><span class="line">favoriteStyle --&gt; |flux不可变| redux&#x2F;vuex</span><br><span class="line">favoriteStyle --&gt; |状态机| xstate_跨框架</span><br></pre></td></tr></table></figure>
<h3 id="Super-Component-Props"><a href="#Super-Component-Props" class="headerlink" title="Super Component Props"></a><code>Super Component Props</code></h3><blockquote>
<p>适合简单的父子组件通信。参考: <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/components-and-props.html">组件 &amp; Props</a></p>
</blockquote>
<p>为什么 <code>props</code> 适合简单的父子通信呢？因为 <code>props</code> 是框架中基础的父子组件通信方式，模板代码也是最少的。</p>
<p>下面是一个简单的示例：将一个组件内输入框的值渲染到另一个组件中。</p>
<p><img src="https://img.rxliuli.com/20200818203510.png" alt="最终效果"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Hello: React.FC&lt;&#123; name: string &#125;&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h3&gt;hello &#123;props.name&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const InputName: React.FC&lt;</span><br><span class="line">  Pick&lt;InputHTMLAttributes&lt;HTMLInputElement&gt;, &quot;value&quot; | &quot;onChange&quot;&gt;</span><br><span class="line">&gt; &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  return &lt;input &#123;...props&#125; &#x2F;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [name, setName] &#x3D; useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;InputName value&#x3D;&#123;name&#125; onChange&#x3D;&#123;(e) &#x3D;&gt; setName(e.target.value)&#125; &#x2F;&gt;</span><br><span class="line">      &lt;Hello name&#x3D;&#123;name&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如题，对于这种简单的父子组件传值，使用 props 是最简单合适的。</p>
<p>下面演示使用其他几种方式的实现</p>
<hr>
<p>使用 context</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const HelloContext &#x3D; React.createContext&lt;&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  setName: (name: string) &#x3D;&gt; void;</span><br><span class="line">&#125;&gt;(&#123;</span><br><span class="line">  name: &quot;&quot;,</span><br><span class="line">  setName: () &#x3D;&gt; &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Hello: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 模板代码</span><br><span class="line">  const context &#x3D; useContext(HelloContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h3&gt;hello &#123;context.name&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const InputName: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 模板代码</span><br><span class="line">  const context &#x3D; useContext(HelloContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;input</span><br><span class="line">      name&#x3D;&#123;context.name&#125;</span><br><span class="line">      onChange&#x3D;&#123;(e) &#x3D;&gt; context.setName(e.target.value)&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [name, setName] &#x3D; useState(&quot;&quot;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;HelloContext.Provider value&#x3D;&#123;&#123; name, setName &#125;&#125;&gt;</span><br><span class="line">      &lt;InputName &#x2F;&gt;</span><br><span class="line">      &lt;Hello &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;HelloContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，加的 context 能被深层子组件读取的优势并未体现出来，反而多了一些模板代码。</p>
<hr>
<p>使用 global state，此处使用 mobx 进行演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板代码</span><br><span class="line">class HelloStore &#123;</span><br><span class="line">  @observable</span><br><span class="line">  name &#x3D; &quot;&quot;;</span><br><span class="line">  @action</span><br><span class="line">  setName(name: string) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const helloStore &#x3D; new HelloStore();</span><br><span class="line"></span><br><span class="line">const Hello: React.FC &#x3D; observer(() &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h3&gt;hello &#123;helloStore.name&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const InputName: React.FC &#x3D; observer(() &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;input</span><br><span class="line">      name&#x3D;&#123;helloStore.name&#125;</span><br><span class="line">      onChange&#x3D;&#123;(e) &#x3D;&gt; helloStore.setName(e.target.value)&#125;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 模板代码</span><br><span class="line">  useMount(() &#x3D;&gt; &#123;</span><br><span class="line">    helloStore.setName(&quot;&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;InputName &#x2F;&gt;</span><br><span class="line">      &lt;Hello &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，store 是全局可用的，但也需要在相应组件内做初始化动作，而非像 props/context 那样受组件生命周期控制，自动的初始化和销毁状态。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const em &#x3D; new EventEmitter&lt;&#123;</span><br><span class="line">  update: [string];</span><br><span class="line">&#125;&gt;();</span><br><span class="line"></span><br><span class="line">const Hello: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 模板代码</span><br><span class="line">  const [name, setName] &#x3D; useState(&quot;&quot;);</span><br><span class="line">  &#x2F;&#x2F; 模板代码</span><br><span class="line">  useEffectOnce(() &#x3D;&gt; &#123;</span><br><span class="line">    em.add(&quot;update&quot;, setName);</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      em.remove(&quot;update&quot;, setName);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h3&gt;hello &#123;name&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const InputName: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 模板代码</span><br><span class="line">  const [name, setName] &#x3D; useState(&quot;&quot;);</span><br><span class="line">  function handleChange(e: ChangeEvent&lt;HTMLInputElement&gt;) &#123;</span><br><span class="line">    const value &#x3D; e.target.value;</span><br><span class="line">    setName(value);</span><br><span class="line">    &#x2F;&#x2F; 模板代码</span><br><span class="line">    em.emit(&quot;update&quot;, value);</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;input name&#x3D;&#123;name&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;InputName &#x2F;&gt;</span><br><span class="line">      &lt;Hello &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，emitter 可以在不改变原有组件(<code>InputName</code>)的情况下在新的组件添加相关的逻辑，但确实会多一些模板代码，且需要维护两次状态。</p>
<h3 id="Context-Provider-Pattern"><a href="#Context-Provider-Pattern" class="headerlink" title="Context/Provider Pattern"></a><code>Context/Provider Pattern</code></h3><blockquote>
<p>适合深层的父组件共享状态给多个子组件，有时候会结合 <code>EventEmitter</code> 一起使用。</p>
</blockquote>
<p>为什么我们有了 props，甚至有了更强大的 <code>render props</code>（vue 中被称为 <code>slot</code>），却还是需要 context 呢？</p>
<p>考虑以下场景，我们想要为一颗组件树的所有组件添加一些全局特性，例如 <code>theme</code>、<code>local</code>、<code>全局配色</code>，而你使用这些状态的组件又分散在各个地方时，便可以考虑使用 context。相比于全局状态，context 仅与框架而非状态管理库绑定，这对于第三方库（尤其是 UI 组件库）是大有益处的，例如 <a target="_blank" rel="noopener" href="https://github.com/react-component/field-form">rc-field-form</a> 和 <a target="_blank" rel="noopener" href="https://github.com/ReactTraining/react-router">react-router</a> 均有如此实现。理论上，当我们需要状态共享但 props 又不需要在组件外操作状态时，就应该首先选择 context。</p>
<p>下面是一个简单的示例来说明使用 context 实现全局的 theme 控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type ThemeContextType &#x3D; &#123;</span><br><span class="line">  color: &quot;light&quot; | &quot;black&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">const ThemeContext &#x3D; React.createContext&lt;ThemeContextType&gt;(&#123;</span><br><span class="line">  color: &quot;light&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">const Theme &#x3D; ThemeContext.Provider;</span><br><span class="line"></span><br><span class="line">const Button: React.FC &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  const context &#x3D; useContext(ThemeContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button className&#x3D;&#123;context.color !&#x3D;&#x3D; &quot;black&quot; ? &quot;light&quot; : &quot;black&quot;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const Tag: React.FC &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">  const context &#x3D; useContext(ThemeContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;span className&#x3D;&#123;context.color !&#x3D;&#x3D; &quot;black&quot; ? &quot;light&quot; : &quot;black&quot;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Theme value&#x3D;&#123;&#123; color: &quot;black&quot; &#125;&#125;&gt;</span><br><span class="line">      &lt;Button&gt;按钮&lt;&#x2F;Button&gt;</span><br><span class="line">      &lt;Tag&gt;标签&lt;&#x2F;Tag&gt;</span><br><span class="line">    &lt;&#x2F;Theme&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题</p>
<ul>
<li>仅限于同一个父组件树下的两个子组件共享状态，当然你也可以说所有的组件都只有<strong>单根</strong>。</li>
<li>无法在组件外部使用，这点是致命的，例如路由 <code>history</code> 对象弹窗无法在逻辑层使用是不可接受的（需要在请求接口报 404 时跳转登录页面）。</li>
<li>使用时的模板代码要稍微更多一点，相比与 mobx 的话。</li>
</ul>
<h3 id="Global-Store"><a href="#Global-Store" class="headerlink" title="Global Store"></a><code>Global Store</code></h3><blockquote>
<p>适合在组件树上相隔较远的组件/组件外共享状态和逻辑使用。</p>
</blockquote>
<p>那么，继续来看以下场景，当我们需要在多个组件/组件外共享状态时，例如当前登录的用户信息，便应该优先考虑使用状态管理器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">interface UserInfo &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  username: string;</span><br><span class="line">  nickname: string;</span><br><span class="line">&#125;</span><br><span class="line">class UserStore &#123;</span><br><span class="line">  @observable</span><br><span class="line">  userInfo?: UserInfo;</span><br><span class="line">  refresh(userInfo: UserInfo) &#123;</span><br><span class="line">    this.userInfo &#x3D; userInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const userStore &#x3D; new UserStore();</span><br><span class="line"></span><br><span class="line">async function post&lt;T&gt;(url: string, data: object) &#123;</span><br><span class="line">  const response &#x3D; await fetch(url, &#123;</span><br><span class="line">    method: &quot;post&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: JSON.stringify(&#123;</span><br><span class="line">      client: &#123;</span><br><span class="line">        &#x2F;&#x2F;在组件外使用用户信息</span><br><span class="line">        uid: userStore.userInfo?.id,</span><br><span class="line">      &#125;,</span><br><span class="line">      data: data,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">  return (await response.json()) as T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type UserInfoForm &#x3D; &#123; username: string; password: string &#125;;</span><br><span class="line">const Login: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [form, dispatchForm] &#x3D; useReducer&lt;</span><br><span class="line">    Reducer&lt;UserInfoForm, &#123; name: keyof UserInfoForm; value: string &#125;&gt;</span><br><span class="line">  &gt;(</span><br><span class="line">    (state, action) &#x3D;&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        [action.name]: action.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; username: &quot;&quot;, password: &quot;&quot; &#125;</span><br><span class="line">  );</span><br><span class="line">  async function handleSubmit(e: FormEvent&lt;HTMLFormElement&gt;) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&quot;handleSubmit: &quot;, form);</span><br><span class="line">    &#x2F;&#x2F;登录时刷新用户信息</span><br><span class="line">    const userInfo &#x3D; await post&lt;UserInfo&gt;(&quot;&#x2F;login&quot;, form);</span><br><span class="line">    userStore.refresh(userInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;handleSubmit&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;label htmlFor&#x3D;&#123;&quot;username&quot;&#125;&gt;用户名：&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          name&#x3D;&#123;&quot;username&quot;&#125;</span><br><span class="line">          value&#x3D;&#123;form.username&#125;</span><br><span class="line">          onChange&#x3D;&#123;(e) &#x3D;&gt;</span><br><span class="line">            dispatchForm(&#123;</span><br><span class="line">              name: &quot;username&quot;,</span><br><span class="line">              value: e.target.value,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;label htmlFor&#x3D;&#123;&quot;password&quot;&#125;&gt;密码：&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          name&#x3D;&#123;&quot;password&quot;&#125;</span><br><span class="line">          type&#x3D;&#123;&quot;password&quot;&#125;</span><br><span class="line">          value&#x3D;&#123;form.password&#125;</span><br><span class="line">          onChange&#x3D;&#123;(e) &#x3D;&gt;</span><br><span class="line">            dispatchForm(&#123;</span><br><span class="line">              name: &quot;password&quot;,</span><br><span class="line">              value: e.target.value,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button type&#x3D;&#123;&quot;submit&quot;&#125;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const App &#x3D; observer(() &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;&#x2F;*在组件中使用 store 的值*&#x2F;&#125;</span><br><span class="line">      &lt;header&gt;&#123;userStore.userInfo?.nickname&#125;&lt;&#x2F;header&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>问题</p>
<ul>
<li>需要自己管理状态的初始化与清理，不跟随组件的生命周期进行变化。</li>
<li>全局状态是混乱的根源，过度使用害人害己</li>
<li>无论何时都存在，占用额外的内存资源</li>
</ul>
<h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a><code>EventEmitter</code></h3><blockquote>
<p>适合用于逻辑层的状态通信或是组件之间的监听/通知操作，不修改组件状态存储的结构，无法复用状态。</p>
</blockquote>
<p>在不想改变组件状态/操作的代码结构而仅仅只是想要简单的通信时，EventEmitter 是一种合适的方式。设想以下场景，当你已经写完了一个复杂的组件，而突然 UI/UX 又在另一个相隔很远的地方添加了另一个相关的组件并且需要通信时，在你不想对原组件大刀阔斧的改动时，那么 EventEmitter 是一个合适的选择。</p>
<p>例如下面这段代码，假设你已经写完了复杂的 MainContent 组件（当然下面代码中的 MainContent 并不算复杂），但后来需求变化，想在 Header 组件中添加一个刷新按钮，而不希望变更代码状态结构的时候，便可以尝试使用 EventEmitter 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 随机数生成器（从 0 开始，不包含最大值）</span><br><span class="line"> * 线性同余生成器</span><br><span class="line"> * @link 网上常能见到的一段 JS 随机数生成算法如下，为什么用 9301, 49297, 233280 这三个数字做基数？ - 猫杀的回答 - 知乎</span><br><span class="line"> https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;22818104&#x2F;answer&#x2F;22744803</span><br><span class="line"> *&#x2F;</span><br><span class="line">export const rand &#x3D; (function () &#123;</span><br><span class="line">  let seed &#x3D; Date.now();</span><br><span class="line">  function rnd() &#123;</span><br><span class="line">    seed &#x3D; (seed * 9301 + 49297) % 233280.0;</span><br><span class="line">    return seed &#x2F; 233280.0;</span><br><span class="line">  &#125;</span><br><span class="line">  return function rand(num: number) &#123;</span><br><span class="line">    return Math.floor(rnd() * num);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">const Header: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;h2&gt;标题&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const MainContent: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [list, setList] &#x3D; useState&lt;number[]&gt;([]);</span><br><span class="line">  function load() &#123;</span><br><span class="line">    setList(</span><br><span class="line">      Array(10)</span><br><span class="line">        .fill(0)</span><br><span class="line">        .map(() &#x3D;&gt; rand(100))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  useMount(() &#x3D;&gt; &#123;</span><br><span class="line">    load();</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map((i) &#x3D;&gt; (</span><br><span class="line">          &lt;li key&#x3D;&#123;i&#125;&gt;&#123;i&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header &#x2F;&gt;</span><br><span class="line">      &lt;MainContent &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 EventEmitter 进行通知，其中的 useEventEmitter hooks 来源于 <a target="_blank" rel="noopener" href="https://blog.rxliuli.com/p/4358e813/">使用 React Hooks 结合 EventEmitter</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">type RefreshEmitterType &#x3D; &#123; refresh: [] &#125;;</span><br><span class="line">const Header: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; emit &#125; &#x3D; useEventEmitter&lt;RefreshEmitterType&gt;();</span><br><span class="line">  return (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;h2&gt;标题&lt;&#x2F;h2&gt;</span><br><span class="line">      &#123;&#x2F;*不同，添加触发操作*&#x2F;&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; emit(&quot;refresh&quot;)&#125;&gt;刷新&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const MainContent: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [list, setList] &#x3D; useState&lt;number[]&gt;([]);</span><br><span class="line">  const load &#x3D; useCallback(() &#x3D;&gt; &#123;</span><br><span class="line">    setList(</span><br><span class="line">      Array(10)</span><br><span class="line">        .fill(0)</span><br><span class="line">        .map(() &#x3D;&gt; rand(100))</span><br><span class="line">    );</span><br><span class="line">  &#125;, []);</span><br><span class="line">  useMount(load);</span><br><span class="line">  &#x2F;&#x2F;不同，添加监听</span><br><span class="line">  const &#123; useListener &#125; &#x3D; useEventEmitter&lt;RefreshEmitterType&gt;();</span><br><span class="line">  useListener(&quot;refresh&quot;, load);</span><br><span class="line">  return (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;list.map((v, i) &#x3D;&gt; (</span><br><span class="line">          &lt;li key&#x3D;&#123;i&#125;&gt;&#123;v&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">const App &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &#x2F;&#x2F;不同</span><br><span class="line">    &lt;EventEmitterRC&gt;</span><br><span class="line">      &lt;Header &#x2F;&gt;</span><br><span class="line">      &lt;MainContent &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;EventEmitterRC&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题</p>
<ul>
<li>需要自己管理事件的注册和清理，不跟随特定组件的生命周期变化。</li>
<li>无论何时都存在，占用额外的内存资源（但相比于全局状态占用的仍然是非常低的）</li>
<li>使用不当可能导致多个组件由重复的状态</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一种解决方案的劣势可能是另一种方案的优势，总是要选择合适的方案才是最好的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/02/a4ea45dd6ba445e1b307ef4e1fd3233e/" data-id="ckmcqox4a006u0kuvazdr7foq" data-title="关于前端组件通信的一些理解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-d55f430907ed4972be823c4979b67fb7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/31/d55f430907ed4972be823c4979b67fb7/" class="article-date">
  <time class="dt-published" datetime="2020-07-30T17:05:24.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/31/d55f430907ed4972be823c4979b67fb7/">React 根据状态动态化功能的一些思考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p>之前吾辈也在 SF 上询问过 <a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000021851252">类似的问题</a>。</p>
</blockquote>
<p>目前在实际业务中遇到了两种情况</p>
<ol>
<li>程序的功能在分发给不同组织使用的时候有所差异，即不同的组织都会存在一些定制化的功能。<br> 最常见的差异例如<ul>
<li>表单的字段存在差异</li>
<li>列表展示的字段与相关操作有所不同</li>
</ul>
</li>
<li>组件内的代码在某个权限下才会执行，但是又依赖于组件内的一些状态，如何将这些代码分割到不同的地方（例如不同的文件）便于之后的维护。<ul>
<li>一些按钮在指定权限下存在</li>
<li>一些数据在指定权限下展示</li>
</ul>
</li>
</ol>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul>
<li>使用动态配置渲染不同的页面(可序列化的配置)</li>
<li>根据状态匹配不同的动态组件</li>
<li>使用 hooks 封装不同的逻辑</li>
<li>使用状态图控制状态和逻辑</li>
</ul>
<h2 id="实际调研结果"><a href="#实际调研结果" class="headerlink" title="实际调研结果"></a>实际调研结果</h2><h3 id="使用动态配置渲染不同的页面"><a href="#使用动态配置渲染不同的页面" class="headerlink" title="使用动态配置渲染不同的页面"></a>使用动态配置渲染不同的页面</h3><p>实际上，之前有看过吾辈写的 <a href="/p/9b07ff8ce6dd4eb08896f6b8191d7181">react 通用列表组件封装</a> 就知道，实际上列表已经被配置化了，可以使用配置的形式去渲染一个完整的列表页面，因此可以根据不同的组织使用不同的配置就好了。但是，事实上并没有这么简单，因为就算是简单的列表，也仍然包含<strong>上下文</strong>，而这，正是配置不能拿到的内容。</p>
<p>上下文主要包括</p>
<ul>
<li>需要异步请求的数据，例如下拉框的选择项</li>
<li>需要从路由上获取的数据，例如搜索条件</li>
<li>需要对页面内的其它组件进行操作时，例如点击按钮有个新增列表项的弹窗</li>
</ul>
<p>可以有几种解决方案</p>
<ul>
<li>通过函数，而不是单纯的配置，这样，可以通过参数解决一些上下文的依赖情况</li>
<li>通过函数且异步，可以解决 api 请求时，此时的 api 必定是可以用的，但是会依赖于 api。</li>
</ul>
<p>但这仍然会带来问题</p>
<ul>
<li>数据不再纯粹，无法序列化。</li>
<li>不同配置依赖的数据可能不同，需要配置自己去解决，那么如果这样想的话，那么配置就需要自行获取数据，而不是外部传递数据了</li>
<li>仍然无法使用<strong>状态</strong></li>
<li>最重要的是，使用函数之后变得不再像是<strong>配置</strong>了</li>
</ul>
<h3 id="根据状态匹配不同的动态组件"><a href="#根据状态匹配不同的动态组件" class="headerlink" title="根据状态匹配不同的动态组件"></a>根据状态匹配不同的动态组件</h3><ul>
<li>配置更为灵活，能够获取到组件的上下文</li>
<li>接口请求也没有问题</li>
<li>对不同配置，可以自行对数据进行处理</li>
</ul>
<p>问题</p>
<ul>
<li>无法如同纯数据配置那样，复用逻辑这么彻底，但是也可以通过 hooks 解决。</li>
<li>UI 复用问题<br>先使用组件的方式编写一下，看具体结果如何</li>
<li>无法序列化也意味着无法放到后端，甚至意味着很难做动态加载</li>
</ul>
<p>使用</p>
<ul>
<li>使用一个 wrapper 组件来讲 UI 和通用逻辑给包裹进去</li>
<li>使用另外一套组件去区分不同租户的配置（因为是在组件内部写配置，所以该配置可以灵活的使用任意接口，组件上下文可能还不太行）也就是用多个组件来解决这个问题。</li>
</ul>
<p>可以再尝试一下有没有解决方案。</p>
<h3 id="使用-hooks-封装不同的代码"><a href="#使用-hooks-封装不同的代码" class="headerlink" title="使用 hooks 封装不同的代码"></a>使用 hooks 封装不同的代码</h3><ul>
<li>相比于处理 <strong>是哪一个</strong>，更适合处理 <strong>有或没有</strong> 的代码分割</li>
<li>能够使用 react 的状态</li>
</ul>
<p>问题</p>
<ul>
<li>使用 hooks 必须放在函数组件最顶层，导致本质上无法 <code>lazy</code> 加载。参考：<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-rules.html">Hook 规则</a></li>
<li>使用 hooks 同样难以序列化存储到后端</li>
</ul>
<h3 id="使用状态图控制状态和逻辑"><a href="#使用状态图控制状态和逻辑" class="headerlink" title="使用状态图控制状态和逻辑"></a>使用状态图控制状态和逻辑</h3><p>使用 hooks 封装代码最适合处理元素级的权限控制，但在面对需要根据多个维度的状态决定程序的状态或行为时，就有点力不从心了。而这，也是为什么有限状态机为什么有用的原因。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最终，我们选择了最灵活的 <strong>动态组件 + Hooks 共享逻辑</strong> 的形式，虽然使用动态组件会增加一些冗余度，但也可以通过子组件或 hooks 的形式复用逻辑，实际上在工程化减小的复杂度的收益是要高于代码冗余的。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><blockquote>
<p>登记相关内容已经使用该方式进行了重构</p>
</blockquote>
<ul>
<li><code>src/pages/register</code><ul>
<li><code>common</code>: 通用的一些组件和逻辑，例如请求后台接口应该是统一的，但返回的数据类型却应该是单独的<ul>
<li><code>form</code>: 表单相关组件，提供给列表/详情页面使用</li>
<li><code>detail</code>: 详情页面</li>
<li><code>list</code>: 列表页面</li>
</ul>
</li>
<li><code>organizations</code>: 不同组织的目录<ul>
<li><code>org1</code>: 组织 1</li>
<li><code>org2</code>: 组织 2</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>吾辈编写了一个简单的示例，代码在 <a target="_blank" rel="noopener" href="https://github.com/rxliuli/example/tree/master/dynamic_state">dynamic_state</a></p>
<p><img src="https://img.rxliuli.com/20200803203027.png" alt="简单示例"></p>
<h2 id="其他技术问题"><a href="#其他技术问题" class="headerlink" title="其他技术问题"></a>其他技术问题</h2><ul>
<li>[x] 如何在运行时根据组织切换功能<ul>
<li>可以再包一层组件而非简单的从 <code>lazy component map</code> 取出组件</li>
</ul>
</li>
<li>[x] 如何在运行时添加新组织的功能<ul>
<li>可能需要插件的实现方式，支持动态加载进来，例如 vscode 的插件体系。</li>
</ul>
</li>
<li>[x] 如何使用 hooks 更好的复用逻辑<ul>
<li>使用 hooks 封装逻辑，使用小型组件封装 UI/UX</li>
</ul>
</li>
<li>[x] 如何在打包阶段干掉不相关组织的代码<ul>
<li>需要修改 webpack 相关的内容，目前不予考虑</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/31/d55f430907ed4972be823c4979b67fb7/" data-id="ckmcqox4x008x0kuva1ss6s32" data-title="React 根据状态动态化功能的一些思考" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c3b0b2b4e98e4e31959fdf1fef1af678" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/16/c3b0b2b4e98e4e31959fdf1fef1af678/" class="article-date">
  <time class="dt-published" datetime="2020-07-16T00:02:59.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/16/c3b0b2b4e98e4e31959fdf1fef1af678/">异步并发调用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你觉得下面这段代码会怎么打印？这里使用异步模拟了 10 个 thread，然后从 generator 里面迭代取值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">sec</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(res, sec * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> group = <span class="function">(<span class="params">arr, kFn</span>) =&gt;</span></span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">res, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> i = kFn(item);</span><br><span class="line">    res[i] = (res[i] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fibGenerator = <span class="function"><span class="keyword">function</span>* (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [a, b] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> fibIterator = fibGenerator(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 开十个 thread</span></span><br><span class="line"><span class="keyword">const</span> idxArr = <span class="built_in">Array</span>(<span class="number">10</span>)</span><br><span class="line">  .fill(<span class="number">0</span>)</span><br><span class="line">  .map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">  idxArr.map(<span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> fibIterator) &#123;</span><br><span class="line">      arr.push([i, num]);</span><br><span class="line">      <span class="comment">// 如果改成 await sleep(0) 呢？</span></span><br><span class="line">      <span class="keyword">await</span> sleep(<span class="built_in">Math</span>.random());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    arr.length,</span><br><span class="line">    arr,</span><br><span class="line">    group(arr, <span class="function">(<span class="params">[i]</span>) =&gt;</span> i)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>主要考察并发异步和迭代器的知识</p>
<p>修改前</p>
<ul>
<li>100 个，因为 generator 只能迭代 100 次</li>
<li>没什么规律的数组，因为队列在第一次之后追加的 idx 顺序是不确定的，会是 1,2,3…9 然后后面线程就不能确定了</li>
<li>每个线程运行次数至少为 1</li>
</ul>
<p>修改后</p>
<ul>
<li>同上</li>
<li>确定的数组，线程是 0,1,2…9 的循环，对应的值则是从 0-99 对应的斐波那契数列递增</li>
<li>确定的对象，每个线程运行次数均为 10</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/16/c3b0b2b4e98e4e31959fdf1fef1af678/" data-id="ckmcqox4r008b0kuveuw10nfs" data-title="异步并发调用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-0eb593b87cbb401692e22e19cae0ea8e" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/10/0eb593b87cbb401692e22e19cae0ea8e/" class="article-date">
  <time class="dt-published" datetime="2020-07-09T17:49:48.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/10/0eb593b87cbb401692e22e19cae0ea8e/">有限状态机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://xstate.js.org/">xstate.js 官网</a>, <a target="_blank" rel="noopener" href="https://blog.jerry-hong.com/posts/xstate-tutorials-context-actions/">中文（繁体）教程参考</a></p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li>为什么要引入状态机？</li>
<li>吾辈希望使用有限状态机管理程序中的状态及状态的流转，以避免使用各种 <code>flag</code> + <code>if/else</code> 控制程序的运行。</li>
<li>为什么吾辈会突然觉得 <code>flag</code> + <code>if/else</code> 这种方式不好呢？</li>
<li>原因在于吾辈最近在看设计模式相关的书籍：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26382780/">JavaScript 设计模式与开发实践</a>，其中涉及到了[状态模式]，里面就提到了[有限状态机]与[状态图]的概念，在经过 Google 一下了解之后，吾辈确实感觉到可以使用它来简化程序的状态流转控制。</li>
</ul>
<p>例如有一个开关，控制灯泡怎么变化，在指定状态下点击会触发不同的行为，然后改变状态。</p>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>想象以下场景，有一个开关控制着一个灯泡，灯泡有三种状态：关闭、打开弱光和打开强光，轮流变化。</p>
<h3 id="使用原生代码实现"><a href="#使用原生代码实现" class="headerlink" title="使用原生代码实现"></a>使用原生代码实现</h3><p>首先，我们尝试简单的使用 <code>if/else</code> 判断进行实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="string">&quot;off&quot;</span> | <span class="string">&quot;weak&quot;</span> | <span class="string">&quot;strong&quot;</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;off&quot;</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;打开弱光&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;weak&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;weak&quot;</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;打开强光&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;strong&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;strong&quot;</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.click();</span><br><span class="line">light.click();</span><br><span class="line">light.click();</span><br></pre></td></tr></table></figure>
<p>然而，这种代码充斥着判断，同时代码本身也都耦合在了一起。目前只有一个 <code>flag</code> 的时候还没太大问题，如果有更多的 flag（例如典型的用户角色与状态同时控制指定操作的行为），代码将非常混乱。</p>
<blockquote>
<p>这也是吾辈之前为什么很想要一种支持多个 key 的 Map 的重要原因之一（其实有点类似数据库中索引的概念了）。</p>
</blockquote>
<h3 id="抽离方法，使用-Map-消除判断"><a href="#抽离方法，使用-Map-消除判断" class="headerlink" title="抽离方法，使用 Map 消除判断"></a>抽离方法，使用 Map 消除判断</h3><p>一般来说，我们都会使用下面的方式去简化代码。</p>
<ol>
<li> 将不同的逻辑抽离为单独的方法</li>
<li> 使用 Map 消除条件判断</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="string">&quot;off&quot;</span> | <span class="string">&quot;weak&quot;</span> | <span class="string">&quot;strong&quot;</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> map = &#123;</span><br><span class="line">    off: <span class="built_in">this</span>.offClick.bind(<span class="built_in">this</span>),</span><br><span class="line">    weak: <span class="built_in">this</span>.weakClick.bind(<span class="built_in">this</span>),</span><br><span class="line">    strong: <span class="built_in">this</span>.strongClick.bind(<span class="built_in">this</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.map[<span class="built_in">this</span>.state]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">offClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打开弱光&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;weak&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">weakClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打开强光&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;strong&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">strongClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.click();</span><br><span class="line">light.click();</span><br><span class="line">light.click();</span><br></pre></td></tr></table></figure>
<p>事实上，第一种方式是卓有成效且任何人都能够无师自通的（分离了实现和控制），但第二种，虽然这里可以简化逻辑的控制，但稍微复杂或是由多个 <code>flag</code> 控制的状态流转则无法使用这种方式抽离出来。</p>
<h3 id="使用简单的状态模式"><a href="#使用简单的状态模式" class="headerlink" title="使用简单的状态模式"></a>使用简单的状态模式</h3><p>下面是用简单的状态模式来简化代码的控制逻辑</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  toggle: <span class="function">(<span class="params">light: Light</span>) =&gt;</span> <span class="built_in">void</span> = FSM.off;</span><br><span class="line">  <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.toggle(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FSM = &#123;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">light: Light</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打开弱光&quot;</span>);</span><br><span class="line">    light.toggle = FSM.weak;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">weak</span>(<span class="params">light: Light</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打开强光&quot;</span>);</span><br><span class="line">    light.toggle = FSM.strong;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">strong</span>(<span class="params">light: Light</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    light.toggle = FSM.off;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.click();</span><br><span class="line">light.click();</span><br><span class="line">light.click();</span><br></pre></td></tr></table></figure>
<p>仔细观察变化</p>
<ol>
<li> 主流程只是做了转发，将操作转发给当前状态的子流程执行</li>
<li> 状态对应的操作都在子流程中修改</li>
</ol>
<p>其实本质上状态模式是将控制流程分散到了各个子流程中，不再集中在一个地方控制。</p>
<h3 id="结合-react-与状态模式"><a href="#结合-react-与状态模式" class="headerlink" title="结合 react 与状态模式"></a>结合 react 与状态模式</h3><p>然后，有趣的地方来了：如何结合状态模式与现有框架？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Light &#123;</span><br><span class="line">  toggle: (light: Light) &#x3D;&gt; void &#x3D; FSM.off;</span><br><span class="line">  click() &#123;</span><br><span class="line">    this.toggle(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const FSM &#x3D; &#123;</span><br><span class="line">  off(light: Light) &#123;</span><br><span class="line">    console.log(&quot;打开弱光&quot;);</span><br><span class="line">    light.toggle &#x3D; FSM.weak;</span><br><span class="line">  &#125;,</span><br><span class="line">  weak(light: Light) &#123;</span><br><span class="line">    console.log(&quot;打开强光&quot;);</span><br><span class="line">    light.toggle &#x3D; FSM.strong;</span><br><span class="line">  &#125;,</span><br><span class="line">  strong(light: Light) &#123;</span><br><span class="line">    console.log(&quot;关灯&quot;);</span><br><span class="line">    light.toggle &#x3D; FSM.off;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [light] &#x3D; useState(new Light());</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;app&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; light.click()&#125;&gt;灯的开关&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App &#x2F;&gt;, document.querySelector(&quot;#app&quot;));</span><br></pre></td></tr></table></figure>
<p>然而，当我们想要即时显示当前状态时，却发现了问题，是的，状态模式中将状态放在 <code>Light</code> 类中，而它并不在 react 的控制范围之内！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 其他代码</span><br><span class="line"></span><br><span class="line">class Light &#123;</span><br><span class="line">  state: &quot;off&quot; | &quot;weak&quot; | &quot;strong&quot; &#x3D; &quot;off&quot;;</span><br><span class="line">  &#x2F;&#x2F; 其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const FSM &#x3D; &#123;</span><br><span class="line">  off(light: Light) &#123;</span><br><span class="line">    console.log(&quot;打开弱光&quot;);</span><br><span class="line">    light.state &#x3D; &quot;weak&quot;;</span><br><span class="line">    light.toggle &#x3D; FSM.weak;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 其他状态的代码</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [light] &#x3D; useState(new Light());</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;app&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; light.click()&#125;&gt;灯的开关&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;p&gt;&#123;light.state&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 其他代码</span><br></pre></td></tr></table></figure>
<p>即便这样做，仍然不会发生变化，因为 Light 是个对象，而我们并未使用 <code>setLight</code> 修改它，所以自然不会发生变化</p>
<h3 id="尝试-react-useReducer"><a href="#尝试-react-useReducer" class="headerlink" title="尝试 react + useReducer"></a>尝试 react + useReducer</h3><p>当然，我们可以使用 <code>useReducer</code> 试试，毕竟它是专门应对复杂逻辑处理的 hooks。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LightState = <span class="string">&#x27;off&#x27;</span> | <span class="string">&#x27;weak&#x27;</span> | <span class="string">&#x27;strong&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FSM: Record&lt;LightState, <span class="function">() =&gt;</span> LightState&gt; = &#123;</span><br><span class="line">  off(): LightState &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开弱光&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;weak&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  weak(): LightState &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打开强光&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;strong&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  strong(): LightState &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;关灯&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;off&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [lightState, lightSend] = useReducer&lt;<span class="function">(<span class="params">state: LightState</span>) =&gt;</span> LightState&gt;(</span><br><span class="line">    (state) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> FSM[state]()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;header&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> lightSend()&#125;&gt;切换&lt;/button&gt;</span><br><span class="line">        每次从 off =&gt; weak 就改变状态</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">      &lt;p&gt;&#123;lightState&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;当前 useState 的值: &#123;num&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，可以看到，FSM 逻辑代码在 react 组件外部时，想要修改 react 组件内部的状态仍然非常困难，只能维护状态机自身的状态，而这显然是没多大用处的。解决方案很简单，使用回调的形式将具体的实现函数放在 react 组件内部，而这，正是 xstate 集成 react 实现的功能之一。</p>
<h2 id="使用-xstate"><a href="#使用-xstate" class="headerlink" title="使用 xstate"></a>使用 xstate</h2><h3 id="react-状态机-xstate"><a href="#react-状态机-xstate" class="headerlink" title="react + 状态机 xstate"></a>react + 状态机 xstate</h3><p>下面是一个使用状态机控制点击开关控制灯泡的示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">enum LightStateEnum &#123;</span><br><span class="line">  Off &#x3D; &#39;off&#39;,</span><br><span class="line">  Weak &#x3D; &#39;weak&#39;,</span><br><span class="line">  Strong &#x3D; &#39;strong&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum LightEventEnum &#123;</span><br><span class="line">  Click &#x3D; &#39;click&#39;,</span><br><span class="line">&#125;</span><br><span class="line">interface LightEvent extends EventObject &#123;</span><br><span class="line">  type: LightEventEnum.Click</span><br><span class="line">  num: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum LightActionEnum &#123;</span><br><span class="line">  EntryWeak &#x3D; &#39;entryWeak&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const lightStateMachine &#x3D; Machine&lt;&#123;&#125;, LightEvent&gt;(&#123;</span><br><span class="line">  initial: LightStateEnum.Off,</span><br><span class="line">  states: &#123;</span><br><span class="line">    [LightStateEnum.Off]: &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        [LightEventEnum.Click]: &#123;</span><br><span class="line">          target: LightStateEnum.Weak,</span><br><span class="line">          actions: LightActionEnum.EntryWeak,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    [LightStateEnum.Weak]: &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        [LightEventEnum.Click]: LightStateEnum.Strong,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    [LightStateEnum.Strong]: &#123;</span><br><span class="line">      on: &#123;</span><br><span class="line">        [LightEventEnum.Click]: LightStateEnum.Off,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const App: React.FC &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const [num, setNum] &#x3D; useState(0)</span><br><span class="line">  const [lightState, lightSend] &#x3D; useMachine(lightStateMachine, &#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">      [LightActionEnum.EntryWeak](_context, event) &#123;</span><br><span class="line">        console.log(&#39;entryOff: &#39;, event.num)</span><br><span class="line">        setNum(num + event.num)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;App&quot;&gt;</span><br><span class="line">      &lt;header&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick&#x3D;&#123;() &#x3D;&gt;</span><br><span class="line">            lightSend(&#123;</span><br><span class="line">              type: LightEventEnum.Click,</span><br><span class="line">              num: 1,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &gt;</span><br><span class="line">          切换</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        每次从 off &#x3D;&gt; weak 就改变状态</span><br><span class="line">      &lt;&#x2F;header&gt;</span><br><span class="line">      &lt;p&gt;&#123;lightState.value&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;当前 useState 的值: &#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看的出来，上面多了很多<strong>模板</strong>代码，但状态机的意图我们却能以声明式的形式构造出来，具体 <code>actions</code> 的实现细节则被分离在 hooks 中。</p>
<h2 id="xstate-概述"><a href="#xstate-概述" class="headerlink" title="xstate 概述"></a>xstate 概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://statecharts.github.io/concepts.html">常用术语</a>, <a target="_blank" rel="noopener" href="https://statecharts.github.io/glossary/">术语参考</a></p>
</blockquote>
<ul>
<li>状态: 任何时候总是有且只有一种状态</li>
<li>事件: 对外暴露事件，通过事件（声明式）触发状态的变化</li>
<li>动作: 触发事件时对应的具体行为，可以以编程的形式影响状态的变化</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>主要问题还是太大了，xstate 想要把所有的状态都用这种方式管理起来，而非仅限于适合的情况。。。（大而全 ）<blockquote>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/dry-worker-hb5ct">在线示例</a></p>
</blockquote>
</li>
<li>[x] 怎么让 TypeScript 提示正确的类型？<ul>
<li>显式声明类型</li>
</ul>
</li>
<li>[x] 怎么在 react 里使用它修改状态<ul>
<li>使用 <code>useMachine</code> 在 react hooks 组件里添加 <code>actions</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/10/0eb593b87cbb401692e22e19cae0ea8e/" data-id="ckmcqox27000m0kuvc3khgvyl" data-title="有限状态机" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ce13ff46242348b094f95e46a915cef2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/03/ce13ff46242348b094f95e46a915cef2/" class="article-date">
  <time class="dt-published" datetime="2020-07-03T04:43:02.000Z" itemprop="datePublished">2020-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/03/ce13ff46242348b094f95e46a915cef2/">JavaScript 中的批处理和缓存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在生产环境遇到了下面这样一个场景：<br>后台在字典表中存储了一些之前需要前后端共同维护的枚举值，并提供根据 <code>type/id</code> 获取字典的 API。所以在渲染列表的时候，有很多列表的字段直接就是字典的 id，而没有经过后台的数据拼装。</p>
<blockquote>
<p>也是吾辈之前写的文章 <a href="/p/9b07ff8ce6dd4eb08896f6b8191d7181">react 通用列表组件封装</a> 中的那个通用列表在实际使用时遇到的问题之一。</p>
</blockquote>
<p>起初，吾辈解决问题的流程如下</p>
<ol>
<li> 确定字典字段，添加转换后的对象类型接口</li>
<li> 将对象列表进行转换得到其中字典字段的所有值</li>
<li> 对字典 id 列表进行去重</li>
<li> 根据 id 列表从后台获取到所有的字典数据</li>
<li> 将获得的字典数据转换为 <strong>id =&gt; 字典</strong> 的 Map</li>
<li> 遍历最初的列表，对里面指定的字典字段进行转换</li>
</ol>
<p>可以看到，上面的步骤虽然不麻烦，但却十分繁琐，需要定义额外的类型不说，还很容易发生错误。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li> 使用 <code>异步批处理 + LRU 缓存</code> 优化性能</li>
<li> 支持异步 <code>formatter</code> 获得更好的使用体验</li>
</ol>
<h2 id="实现异步批处理"><a href="#实现异步批处理" class="headerlink" title="实现异步批处理"></a>实现异步批处理</h2><blockquote>
<p>参考实现: <a target="_blank" rel="noopener" href="https://github.com/rxliuli/rx-util/blob/dev/src/module/function/batch.ts">batch</a></p>
</blockquote>
<p>实现批处理的基本思路如下</p>
<ol>
<li> 使用 <code>Map</code> <code>paramCache</code> 缓存传入的 <code>参数 =&gt; 剩余调用次数</code>（该参数还需要查询几次结果）</li>
<li> 使用 <code>Map</code> <code>resultCache</code> 缓存 <strong>参数 =&gt; 结果</strong></li>
<li> 使用 <code>lock</code> 标识当前是否有函数正在执行</li>
<li>满足以下条件需要等待<ol>
<li> Map 中不包含结果</li>
<li> 目前有其它调用在执行</li>
<li> 还未满最小等待时长（收集调用的最小时间片段）</li>
</ol>
</li>
<li> 使用 <code>lock</code> 标识正在执行</li>
<li>判断是否已经存在结果<ol>
<li> 如果不存在则执行批处理处理当前所有的参数</li>
</ol>
</li>
<li> 从缓存 Map 中获取结果</li>
<li> 将 <code>paramCache</code> 中对应参数的 <code>剩余调用次数 -1</code></li>
<li>判断是否还需要保留该缓存（该参数对应的剩余调用次数为 0）<ol>
<li> 不需要则删除</li>
</ol>
</li>
<li>判断缓存的结果是否是 <code>Error</code><ol>
<li> 是的话则 <code>throw</code> 抛出错误</li>
</ol>
</li>
</ol>
<h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><blockquote>
<p>参考: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Wiki 缓存算法</a>, 实现 <a target="_blank" rel="noopener" href="https://github.com/rxliuli/rx-util/blob/dev/src/module/cache/MemoryCache.ts">MemoryCache</a></p>
</blockquote>
<ul>
<li>问：这里为什么使用缓存？</li>
<li>答：这里的字典接口在大概率上是<strong>幂等</strong>的，所以可以使用缓存提高性能</li>
<li>问：那么缓存策略为什么要选择 LRU 呢？</li>
<li>答：毫无疑问 <code>FIFO</code> 是不合理的</li>
<li>问：那为什么不选择 <code>LFU</code> 算法呢？它似乎能保留访问最频繁的资源</li>
<li>答：因为字典表并非完全幂等，吾辈希望避免一种可能–<strong>访问最多的字典一直没有删除，而它在数据库已经被更新了</strong>。</li>
</ul>
<p>大致实现思路如下</p>
<ol>
<li> 使用一个 <code>Map</code> 记录 <strong>缓存 key =&gt; 最后访问时间</strong></li>
<li> 每次获取缓存时更新最后访问时间</li>
<li>添加新的缓存时检查缓存数量<ol>
<li> 如果超过最大数量，则删除最后访问时间距离现在最长的一个缓存</li>
</ol>
</li>
<li> 添加新的缓存</li>
</ol>
<blockquote>
<p>Pass: 不要吐槽性能很差啦，这个场景下不会缓存特别多的元素啦，最多也就不到 1000 个吧</p>
</blockquote>
<h2 id="结合高阶函数"><a href="#结合高阶函数" class="headerlink" title="结合高阶函数"></a>结合高阶函数</h2><p>现在，我们可以结合这两种方式了，同时使用 <code>onceOfSameParam/batch</code> 两个高阶函数来优化 <strong>根据 id 获取字典信息</strong> 的 API 了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getById = onceOfSameParam(</span><br><span class="line">  batch&lt;[<span class="built_in">number</span>], Dict&gt;(<span class="keyword">async</span> (idList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (idList.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一次批量处理多个 id</span></span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> <span class="built_in">this</span>.getByIdList(uniqueBy(idList.flat()));</span><br><span class="line">    <span class="keyword">return</span> arrayToMap(</span><br><span class="line">      list,</span><br><span class="line">      (dict) =&gt; [dict.id],</span><br><span class="line">      (dict) =&gt; dict</span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="支持异步-formatter"><a href="#支持异步-formatter" class="headerlink" title="支持异步 formatter"></a>支持异步 formatter</h2><p>原本想要支持 ListTable 的异步 <code>formatter</code> 函数，但后来想想，如果 <code>slot</code> 里也包含字典 id 呢？那是否 <code>slot</code> 也要支持异步呢？这可是个比较棘手的问题，所以还是不支持好了。</p>
<blockquote>
<p>最终，吾辈在组件与 API 之间添加了 <code>*Service</code> 中间层负责处理数据转换。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/03/ce13ff46242348b094f95e46a915cef2/" data-id="ckmcqox4w008r0kuvbhrs50ha" data-title="JavaScript 中的批处理和缓存" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5ee4baf7db80466387689bbb291aa11a" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/01/5ee4baf7db80466387689bbb291aa11a/" class="article-date">
  <time class="dt-published" datetime="2020-05-01T03:19:34.000Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/01/5ee4baf7db80466387689bbb291aa11a/">Android 上最好的浏览器 Kiwi browser</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://kiwibrowser.com/">官网</a></p>
</blockquote>
<p>或许对于现在很多人来说，浏览器是一个很少使用的 App，因为所有功能都可以在 App 做，不需要使用浏览器。一方面，是由于国内的大环境就是把用户当成傻瓜（事实上，即便是吾辈目前所在的公司，在 UI/UX 设计方面也倾向于将用户当成傻瓜），导致用户真的是越来越傻瓜，甚至遇到了除了微信其他的都不怎么会用的地步，更何况浏览器这种“<strong>高端</strong>”的 App 呢？<br>然而对于某些特定人群来说，尤其是不喜欢安装太多 App 的人来说，浏览器几乎是 App 上数一数二的应用了，甚至称之为互联网的入口都不为过（现在一般的傻瓜式用户大概认为微信才是吧，缅怀曾经互联网都是通过浏览器使用的时代）。<br>在使用过 <em>UC =&gt; Chrome =&gt; FireFox =&gt; Kiwi browser</em> 之后，吾辈可以确定的说，Kiwi browser 是目前 Android 上最好的浏览器，其中尤以支持 Chrome PC 版的 Plugin 最为有名。</p>
<h2 id="使用过的浏览器"><a href="#使用过的浏览器" class="headerlink" title="使用过的浏览器"></a>使用过的浏览器</h2><h3 id="UC-浏览器（国内版）"><a href="#UC-浏览器（国内版）" class="headerlink" title="UC 浏览器（国内版）"></a>UC 浏览器（国内版）</h3><p>在早期吾辈使用的浏览器中，UC 绝对是当年（2016 年之前）使用体验非常好的浏览器，直到后来被阿里系收购，导致它逐渐充斥着各种广告，甚至首先开辟出了<a target="_blank" rel="noopener" href="http://kf.uc.cn/self_service/web/faqdetails-8311412_9210815_20559164_5.html">浏览器收费</a>这一跨世纪倒车壮举。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141319.jpg" alt="UC 国内版首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141320.png" alt="UC 国内版搜索"></p>
<blockquote>
<p>附：这里的跨世纪倒车壮举指的是自从浏览器始祖 Netscape 被 MS 的 IE 使用系统捆绑 + 免费的策略干掉以后，后来流行起来的浏览器还从未出现过收费的（或许是吾辈孤陋寡闻了？）<br>附：所有的国内浏览器都有内置的黑名单，例如 GitHub 上的 996 icu 就被国内浏览器屏蔽了，不仅仅是墙，就连浏览器都是墙的帮凶。参考：<a target="_blank" rel="noopener" href="http://kf.uc.cn/self_service/web/faqdetails-9212655_9212659_20389994_6.html">国外网站无法访问？</a></p>
</blockquote>
<h3 id="UC-浏览器（国际版）"><a href="#UC-浏览器（国际版）" class="headerlink" title="UC 浏览器（国际版）"></a>UC 浏览器（国际版）</h3><p>UC 国际版，这是一个比较有趣的版本，没有国内版那么多花俏无用的功能，但同时不支持简体中文（当然支持繁体中文），同时保留了 UC 的核心功能——怪不得手机上 UC 的使用占有率很高呢！<br>它默认支持的主要功能如下</p>
<ul>
<li>广告过滤</li>
<li>黑暗模式</li>
<li>手势方面几近完美</li>
<li>下载功能</li>
<li>自带 QR</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141317.png" alt="UC 国际版首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141318.png" alt="UC 国际版搜索"></p>
<p>看起来没什么太大的问题，然而，它却在隐私方面做的一如既往的烂，参考：<a target="_blank" rel="noopener" href="https://web.archive.org/web/20180228041423/http://news.163.com/16/0330/10/BJDBF3TT00014AEE.html">美媒:中国人上网须防泄露隐私 浏览器存安全隐患</a></p>
<h3 id="Chrome-for-Android"><a href="#Chrome-for-Android" class="headerlink" title="Chrome for Android"></a>Chrome for Android</h3><p>后来，吾辈在 PC 上先后遇到了 FireFox 和 Chrome，简直比国内的各种浏览器干净整洁了一百倍。在实际使用过相当长的一段时间后，吾辈最终在 PC 上选择了 Chrome，手机上也安装了 Chrome 进行网页浏览，它的速度非常理想，使用体验也还算不错，尤其是翻译功能更是被完整地保留了下来。唯有一点，插件功能被整个砍掉了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141709.png" alt="Chrome 首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141404.png" alt="Chrome 搜索"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141403.png" alt="Google 翻译功能"></p>
<blockquote>
<p>为什么 Chrome For Android 不支持插件？虽然官方说是为了使之能够在较旧的浏览器上也能正常运行，但实际上应该有两个原因</p>
<ol>
<li> Android 是 Google 自己的，而 Google 对于 App 的控制力要超过网页，所以为了让用户使用 App，Google 不原因让用户更多的浏览网页。</li>
<li> 大约 70％的 chrome 用户在 android 和 ios 端，只有 30％的 chrome 用户在台式机和 mac 上。谷歌知道，如果他们在智能手机上引入扩展功能，那么由于广告拦截器的存在，他们将损失很多钱，而且大多数互联网用户由于舒适性，大部分时间都倾向于将智能手机用于互联网。Google 在这里玩一个聪明的游戏。参考：<a target="_blank" rel="noopener" href="https://www.quora.com/Why-arent-there-any-extensions-for-Google-Chrome-on-Android">https://www.quora.com/Why-arent-there-any-extensions-for-Google-Chrome-on-Android</a></li>
</ol>
</blockquote>
<h3 id="FireFox-for-Android"><a href="#FireFox-for-Android" class="headerlink" title="FireFox for Android"></a>FireFox for Android</h3><p>所以，在知道 FireFox 在 Android 上亦支持插件后，吾辈感觉它就是吾辈理想中的手机浏览器，吾辈在手机上也开始尝试使用 FireFox 了。但事与愿违，它真的太慢了。。。在使用体验上和 Chrome 无法相提并论,而且翻译插件的支持不完善导致有时候想在移动端阅读大量英文网页时还需要切到 Chrome.</p>
<blockquote>
<p>注：FireFox 的桌面版插件支持存在一些问题，同时插件官方一直未曾修复，这也是吾辈放弃 FireFox 的重要原因之一。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141432.png" alt="FireFox 首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141433.png" alt="FireFox 搜索"></p>
<h3 id="Kiwi-browser"><a href="#Kiwi-browser" class="headerlink" title="Kiwi browser"></a>Kiwi browser</h3><p>最终，吾辈遇到了 Kiwi browser，诚然，它也不是十全十美的，也有很多缺点。</p>
<ul>
<li>默认主页的新闻资讯很讨厌，而且还无法关闭。</li>
<li>翻译功能没有 Chrome 强大，没有<strong>就地</strong>全文翻译的功能</li>
<li>不是一个非常流行的浏览器，没有桌面版本，没有同步功能</li>
</ul>
<p>但有一个及其突出的优点，足以掩盖以上的所有缺点 – 支持 Chrome 桌面版插件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141349.png" alt="Kiwi 首页"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141348.png" alt="Kiwi 翻译"></p>
<h3 id="微型浏览器"><a href="#微型浏览器" class="headerlink" title="微型浏览器"></a>微型浏览器</h3><p>事实上，吾辈也曾断断续续地使用过一些微型浏览器，在功能上做的比较简洁（但并不意味着不够用），但内核却薄弱不堪（其实就是用系统默认浏览器的内核）。<br>包括但不限于以下列表</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://play.google.com/store/apps/details?id=mark.via.gp&hl=en_US">via 浏览器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.coolapk.com/apk/org.noear.h5">h5 浏览器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.xbext.com/">X 浏览器</a></li>
</ul>
<p>其他吾辈没有使用过的浏览器可以参考：<a target="_blank" rel="noopener" href="https://m.xianjichina.com/news/details_145337.html">手机浏览器有哪些？安卓平台良心浏览器推荐</a></p>
<p>虽然这些微型浏览器理念很好：<strong>少即是多，简单就是美！</strong>，但实际上，这些没有内核的浏览器很多地方，尤其是性能方面，仍然受限于系统默认浏览器。大多数自带的插件系统，往往只是实现了一套加载 <code>*.user.js</code> 的机制罢了，而且生态之小与 Chrome/FireFox 这些主流其相比往往是天壤之别。</p>
<h2 id="Kiwi-browser-配置"><a href="#Kiwi-browser-配置" class="headerlink" title="Kiwi browser 配置"></a>Kiwi browser 配置</h2><h3 id="Kiwi-browser-推荐的插件"><a href="#Kiwi-browser-推荐的插件" class="headerlink" title="Kiwi browser 推荐的插件"></a>Kiwi browser 推荐的插件</h3><ul>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a>：广告过滤</li>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh">Dark Reader</a>：为所有网站加上黑色主题，大部分情况下都还不错</li>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp">Tabliss</a>：美丽的新标签页</li>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd">LastPass</a>：全平台密码管理器</li>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">Tampermonkey</a>：油猴脚本管理器</li>
</ul>
<blockquote>
<p>桌面的 Chrome 使用建议可以参考：<a target="_blank" rel="noopener" href="https://blog.rxliuli.com/p/54be2845/">优化 Google Chrome 的使用体验</a></p>
</blockquote>
<h3 id="二维码扫描"><a href="#二维码扫描" class="headerlink" title="二维码扫描"></a>二维码扫描</h3><p>有时候需要使用二维码扫描使用手机去打开某个网站，而 Kiwi 并没有自带这个功能，所以需要配合 App <a target="_blank" rel="noopener" href="https://play.google.com/store/apps/details?id=mark.qrcode">二维码扫描</a> 食用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/01/5ee4baf7db80466387689bbb291aa11a/" data-id="ckmcqox3h00460kuvggdz986r" data-title="Android 上最好的浏览器 Kiwi browser" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ddcef057b6fa4f4bb8707e0978665f7c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/27/ddcef057b6fa4f4bb8707e0978665f7c/" class="article-date">
  <time class="dt-published" datetime="2020-04-27T03:37:43.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/27/ddcef057b6fa4f4bb8707e0978665f7c/">JavaScript 禁止用户保存图片</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在业务需求中不希望用户保存图片，因为是一些供内部使用的图片。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>添加事件禁止选择、拖拽、右键（简单的禁止用户保存图片，但无法阻止用户打开控制台查看，或是直接抓包）</li>
<li>将之转换为 canvas（让浏览器认为不是图片以此禁止用户对之进行图片的操作，但无法阻止抓包）</li>
<li>禁止用户使用控制台查看源码（阻止浏览器打开控制台，但无法阻止抓包）</li>
<li>传输图片使用自定义格式（可以阻止抓包，但需要后台配合）</li>
</ul>
<blockquote>
<p>注：以下内容使用 react+ts 实现</p>
</blockquote>
<h2 id="添加事件禁止选择、拖拽、右键"><a href="#添加事件禁止选择、拖拽、右键" class="headerlink" title="添加事件禁止选择、拖拽、右键"></a>添加事件禁止选择、拖拽、右键</h2><p>简而言之，这是一种简单有效的方式，能够在用户不打开控制台的情况下阻止用户保存图片。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">preventDefaultListener</span>(<span class="params">e: any</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;img</span><br><span class="line">  src=&#123;props.url&#125;</span><br><span class="line">  alt=<span class="string">&quot;&quot;</span></span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="comment">//禁止用户选择</span></span><br><span class="line">    userSelect: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="comment">//禁止所有鼠标事件，过于强大，图片仅用于展示可用</span></span><br><span class="line">    <span class="comment">// pointerEvents: &#x27;none&#x27;,</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">  onTouchStart=&#123;preventDefaultListener&#125;</span><br><span class="line">  onContextMenu=&#123;preventDefaultListener&#125;</span><br><span class="line">  onDragStart=&#123;preventDefaultListener&#125;</span><br><span class="line">/&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dxzg/p/9930559.html">https://www.cnblogs.com/dxzg/p/9930559.html</a></p>
</blockquote>
<h2 id="将之转换为-canvas"><a href="#将之转换为-canvas" class="headerlink" title="将之转换为 canvas"></a>将之转换为 canvas</h2><p>另一种思路是将图片转换为 canvas 避免用户使用 <code>img</code> 相关的操作。</p>
<ol>
<li><p>将图片转成 canvas</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">imageToCanvas</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  url: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  canvas: HTMLCanvasElement</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//新建Image对象，引入当前目录下的图片</span></span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = url;</span><br><span class="line">    <span class="keyword">const</span> c = canvas.getContext(<span class="string">&quot;2d&quot;</span>)!;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片初始化完成后调用</span></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//将canvas的宽高设置为图像的宽高</span></span><br><span class="line">      canvas.width = img.width;</span><br><span class="line">      canvas.height = img.height;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//canvas画图片</span></span><br><span class="line">      c.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;;</span><br><span class="line">    img.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>禁用 canvas 事件</p>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throwFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">&quot;Uncaught DOMException: Failed to execute &#x27;toDataURL&#x27; on &#x27;HTMLCanvasElement&#x27;: Tainted canvases may not be exported.&quot;</span>,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $canvasRef = useRef&lt;HTMLCanvasElement&gt;(<span class="literal">null</span>)</span><br><span class="line"> useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     ;(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">         <span class="keyword">await</span> imageToCanvas(props.url, $canvasRef.current!)</span><br><span class="line">         $canvasRef.current!.toBlob = throwFn</span><br><span class="line">         $canvasRef.current!.toDataURL = throwFn</span><br><span class="line">     &#125;)()</span><br><span class="line"> &#125;, [])</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     &lt;canvas</span><br><span class="line">         ref=&#123;$canvasRef&#125;</span><br><span class="line">         onTouchStart=&#123;preventDefaultListener&#125;</span><br><span class="line">         onContextMenu=&#123;preventDefaultListener&#125;</span><br><span class="line">     /&gt;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<h2 id="禁止用户使用控制台查看源码"><a href="#禁止用户使用控制台查看源码" class="headerlink" title="禁止用户使用控制台查看源码"></a>禁止用户使用控制台查看源码</h2></li>
</ol>
<p>如果能禁止用户操作控制台，那么自然能够避免用户查看源码了，下面是一个简单的实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 兼容异步函数的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>res 返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>callback 同步/异步结果的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typeparam </span>T 处理参数的类型，如果是 Promise 类型，则取出其泛型类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typeparam </span>Param 处理参数具体的类型，如果是 Promise 类型，则指定为原类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typeparam </span>R 返回值具体的类型，如果是 Promise 类型，则指定为 Promise 类型，否则为原类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>处理后的结果，如果是同步的，则返回结果是同步的，否则为异步的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compatibleAsync</span>&lt;<span class="title">T</span> = <span class="title">any</span>, <span class="title">Param</span> = <span class="title">T</span> | <span class="title">Promise</span>&lt;<span class="title">T</span>&gt;, <span class="title">R</span> = <span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  res: Param,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: (r: T) =&gt; R</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Param</span> <span class="title">extends</span> <span class="title">Promise</span>&lt;<span class="title">T</span>&gt; ? <span class="title">Promise</span>&lt;<span class="title">R</span>&gt; : <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (res <span class="keyword">instanceof</span> <span class="built_in">Promise</span></span><br><span class="line">    ? res.then(callback)</span><br><span class="line">    : callback(res <span class="keyword">as</span> <span class="built_in">any</span>)) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试函数的执行时间</span></span><br><span class="line"><span class="comment"> * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 需要测试的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>执行的毫秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>&lt;<span class="title">R</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; R</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 函数返回类型是 Promise 的话，则返回 Promise&lt;number&gt;，否则返回 number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">R</span> <span class="title">extends</span> <span class="title">Promise</span>&lt;<span class="title">any</span>&gt; ? <span class="title">Promise</span>&lt;<span class="title">number</span>&gt; : <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begin = performance.now();</span><br><span class="line">  <span class="keyword">const</span> res = fn();</span><br><span class="line">  <span class="keyword">return</span> compatibleAsync(res, <span class="function">() =&gt;</span> performance.now() - begin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止他人调试网站相关方法的集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AntiDebug</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 不停循环 debugger 防止有人调试代码</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>取消函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> cyclingDebugger(): <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查是否正在 debugger 并调用回调函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>fn 回调函数，默认为重载页面</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>取消函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> checkDebug(</span><br><span class="line">    fn: <span class="built_in">Function</span> = <span class="function">() =&gt;</span> <span class="built_in">window</span>.location.reload()</span><br><span class="line">  ): <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> diff = timing(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">debugger</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (diff &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(diff);</span><br><span class="line">        fn();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cancel1 = AntiDebug.cyclingDebugger() <span class="keyword">as</span> any</span><br><span class="line">  <span class="keyword">const</span> cancel2 = AntiDebug.checkDebug(<span class="function">() =&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请不要打开调试&#x27;</span>),</span><br><span class="line">  ) <span class="keyword">as</span> any</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    cancel1()</span><br><span class="line">    cancel2()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;url&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="传输图片使用自定义格式"><a href="#传输图片使用自定义格式" class="headerlink" title="传输图片使用自定义格式"></a>传输图片使用自定义格式</h2><p>该功能需要服务端配合，故而此处赞不实现，可以参考 <a target="_blank" rel="noopener" href="https://weread.qq.com/">微信读书</a>，就是将文本转为 canvas，数据传输也进行了加密，可以在很大程度上防止普通用户想要复制/下载的行为了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如同所有的前端限制用户的技术一样，这是一个没有终点的斗争。。。</p>
<blockquote>
<p>参考广告屏蔽和屏蔽复制粘贴的发展。。。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/27/ddcef057b6fa4f4bb8707e0978665f7c/" data-id="ckmcqox53009j0kuv7fdr47lk" data-title="JavaScript 禁止用户保存图片" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-0540dc0bb40e41c58e19c3b827aba1cd" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/18/0540dc0bb40e41c58e19c3b827aba1cd/" class="article-date">
  <time class="dt-published" datetime="2020-04-18T02:14:09.000Z" itemprop="datePublished">2020-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/18/0540dc0bb40e41c58e19c3b827aba1cd/">MySQL 获取随机条数据</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有一个需要从数据库随机获取指定数量的数据的需求，然而这个问题却是意外的挺麻烦。</p>
<p>假设有一个数据表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> topic (</span><br><span class="line">  id      <span class="type">int</span> <span class="keyword">primary</span> <span class="keyword">key</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">  comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  content <span class="type">varchar</span>(<span class="number">20</span>)     <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">  comment <span class="string">&#x27;内容&#x27;</span></span><br><span class="line">)</span><br><span class="line">  comment <span class="string">&#x27;主题表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 <code>topic</code> 表有两个关键性的特点</p>
<ul>
<li>主键可以进行比较（<code>int</code>）</li>
<li>主键整体存在趋势（自增/自减）</li>
</ul>
</blockquote>
<h2 id="解决方案-1：直接使用-order-by-rand"><a href="#解决方案-1：直接使用-order-by-rand" class="headerlink" title="解决方案 1：直接使用 order by rand()"></a>解决方案 1：直接使用 <code>order by rand()</code></h2><p>直接使用 <code>order by rand()</code> 就可以获取到随机的数据了，而且能够获取到全部的数据（顺序仍然是随机的）。</p>
<ol>
<li>按照 <code>rand()</code> 产生的结果<blockquote>
<p>这一步相当于为每条数据加上一列由 <code>rand()</code> 函数产生的数据，然后对这一列进行排序</p>
</blockquote>
</li>
<li> 限制查询条数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> topic</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> rand()</span><br><span class="line">limit <span class="number">50000</span>;</span><br></pre></td></tr></table></figure>
<p>但缺点很明显，速度是个问题，因为 rand() 的数据没有索引，所以会造成排序速度极慢。</p>
<p>在 10w 条数据中随机获取 5w 条数据，花费时常 <strong>6 s 378 ms</strong>，这个时间真的太长了点。</p>
<p>其实 <code>order by rand()</code> 看起来很奇怪，实际上等效于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">       <span class="keyword">select</span></span><br><span class="line">         topic.<span class="operator">*</span>,</span><br><span class="line">         rand() <span class="keyword">as</span> order_column</span><br><span class="line">       <span class="keyword">from</span> topic</span><br><span class="line">     ) <span class="keyword">as</span> temp</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> order_column</span><br><span class="line">limit <span class="number">50000</span>;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案-2：使用-where-subquery-取中间的随机值"><a href="#解决方案-2：使用-where-subquery-取中间的随机值" class="headerlink" title="解决方案 2：使用 where subquery 取中间的随机值"></a>解决方案 2：使用 <code>where subquery</code> 取中间的随机值</h2><p>因为 <code>order by rand()</code> 没有索引导致的排序太耗时，我们可以尝试绕过这个问题。</p>
<p>下面的这种解决方案便是如此</p>
<ol>
<li> 取最小值和最大值之间的随机值</li>
<li> 判断 id 是否大于（或者小于）这个随机值</li>
<li> 限制查询条数</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> topic</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">&gt;=</span> ((<span class="keyword">select</span> <span class="built_in">max</span>(id)</span><br><span class="line">              <span class="keyword">from</span> topic)</span><br><span class="line">             <span class="operator">-</span> (<span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">                <span class="keyword">from</span> topic))</span><br><span class="line">            <span class="operator">*</span> rand()</span><br><span class="line">            <span class="operator">+</span> (<span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">               <span class="keyword">from</span> topic)</span><br><span class="line">limit <span class="number">50000</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法查询速度虽然极快（150 ms），但却会受到数据分布密度的影响。如果数据不是平均的，那么查询到的总数据条数就会受限。</p>
<p>那么，下面来说该方法的缺陷</p>
<ul>
<li><p>获取到的数据受分布密度影响</p>
<p>例如数据分布呈以下情况</p>
<p><code>1,100002,100003,100004...199999,200000</code></p>
<p>那么使用上述代码就只能获取到很少一部分数据（大约在 2.5w 条左右）。然而如果将符号稍微下改一下，将 <code>&gt;=</code> 修改为 <code>&lt;=</code>，那么能够获取到的平均数量将大大增加（7.5w 条左右）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> topic</span><br><span class="line"># 注意：这里的符号修改了</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">&gt;=</span> ((<span class="keyword">select</span> <span class="built_in">max</span>(id)</span><br><span class="line">              <span class="keyword">from</span> topic)</span><br><span class="line">            <span class="operator">-</span> (<span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">                <span class="keyword">from</span> topic))</span><br><span class="line">            <span class="operator">*</span> rand()</span><br><span class="line">            <span class="operator">+</span> (<span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">              <span class="keyword">from</span> topic)</span><br><span class="line">limit <span class="number">50000</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>每一条数据获取到的概率不是完全相同的<br>虽然获取到的全部数据是随机的，但每一个的概率却并不相同。例如在 <code>&lt;=</code> 时会出现永远都为第一条的现象，究其原因就是因为 <strong>第一条</strong> 的概率实在是太大了，因为查询数据表时数据的检索规则是从第一条开始的呢！即便修改成 <code>&gt;=</code>，所得到的第一条数据也普遍偏小。<br>使用 <code>&gt;=</code> 的结果</p>
<ul>
<li>数据越是在前面，那么获取到的概率就越低</li>
<li>但即便是很低概率，在最前面总有机会，所以第一条一般偏小</li>
<li>数据密度前面偏大时，获取到的数量会非常小</li>
</ul>
</li>
</ul>
<p>密度越是趋于平均，获取到的最大随机数据条数的平均值愈接近 <code>1/2</code>，否则则会愈加偏离（不一定偏大还是偏小）。</p>
<h2 id="解决方案-3：使用临时表-temporary-table"><a href="#解决方案-3：使用临时表-temporary-table" class="headerlink" title="解决方案 3：使用临时表 temporary table"></a>解决方案 3：使用临时表 <code>temporary table</code></h2><p>解决方案 2 着眼于避免使用没有索引的 <code>rand()</code> 进行排序，但这里思考另一个解决方案，使用加了索引之后的 <code>rand()</code> 进行排序。创建临时表，仅包含主键 <code>id</code> 和需要进行排序的索引列 <code>randomId</code>，然后排序完成过后获取到乱序数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> temporary <span class="keyword">table</span> if <span class="keyword">exists</span> temp_topic;</span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_topic (</span><br><span class="line">  id       <span class="type">bigint</span> <span class="keyword">primary</span> <span class="keyword">key</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  randomId <span class="keyword">double</span>             <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  index (randomId)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">as</span></span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      id,</span><br><span class="line">      rand() <span class="keyword">as</span> randomId</span><br><span class="line">    <span class="keyword">from</span> topic;</span><br><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> topic t</span><br><span class="line">  <span class="keyword">join</span> (</span><br><span class="line">         <span class="keyword">select</span> id</span><br><span class="line">         <span class="keyword">from</span> (</span><br><span class="line">                <span class="keyword">select</span> id</span><br><span class="line">                <span class="keyword">from</span> temp_topic</span><br><span class="line">                <span class="keyword">order</span> <span class="keyword">by</span> randomId</span><br><span class="line">              ) <span class="keyword">as</span> temp</span><br><span class="line">         limit <span class="number">50000</span></span><br><span class="line">       ) <span class="keyword">as</span> temp</span><br><span class="line">    <span class="keyword">on</span> t.id <span class="operator">=</span> temp.id;</span><br></pre></td></tr></table></figure>
<p>这种方法的查询速度不算很快（878 ms，相比于第二种），而且仍然是与数据量呈正相关的（因为要复制数据）。但和第一种，也是真正的随机获取。</p>
<h2 id="解决方案-4：使用-join-order-by-rand"><a href="#解决方案-4：使用-join-order-by-rand" class="headerlink" title="解决方案 4：使用 join order by rand()"></a>解决方案 4：使用 <code>join order by rand()</code></h2><p>吾辈在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/">StackOverflow</a> 上面看到了一个 <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/36013954/8409380">最优解 by 2016</a>，一切表现的都很好，速度不算慢（261 ms），也可以获取到全部数据，也是真正的随机获取。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> g.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  topic g</span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line">  (<span class="keyword">select</span> id</span><br><span class="line">   <span class="keyword">from</span></span><br><span class="line">     topic</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">     rand() <span class="operator">&lt;</span> (<span class="keyword">select</span> ((<span class="number">50000</span> <span class="operator">/</span> <span class="built_in">count</span>(<span class="number">0</span>)) <span class="operator">*</span> <span class="number">10</span>)</span><br><span class="line">               <span class="keyword">from</span></span><br><span class="line">                 topic)</span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span> rand()</span><br><span class="line">   limit <span class="number">50000</span>) <span class="keyword">as</span> z <span class="keyword">on</span> z.id <span class="operator">=</span> g.id;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>where rand()</code> 是想要在获取的数据与总数据量差距过大（10 倍以上）时过滤数据，提高排序效率。</p>
<p>吾辈这里不清楚上面发生了什么，感觉 <code>rand()</code> 只要在 <code>join</code> 里面之后的排序就会变得很快！<br>事实上，只要使用 <code>join</code> 内连接之后，就算是 <code>order by rand()</code> 的效率也很高，甚至在获取少量数据时比上面使用 <code>where rand</code> 过滤数据后再排序的的速度还要快</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> topic t</span><br><span class="line">  <span class="keyword">JOIN</span></span><br><span class="line">  (<span class="keyword">SELECT</span> id</span><br><span class="line">   <span class="keyword">FROM</span> `topic`</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> RAND()</span><br><span class="line">   LIMIT <span class="number">50000</span>) <span class="keyword">AS</span> z <span class="keyword">ON</span> z.id <span class="operator">=</span> t.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在获取的数据量很大时，使用上面那种 <code>where</code> 过滤一次的效率上会更有优势一点！</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>这里有一篇不错的英文文章对随机获取数据进行了分析：<a target="_blank" rel="noopener" href="http://jan.kneschke.de/projects/mysql/order-by-rand/">http://jan.kneschke.de/projects/mysql/order-by-rand/</a>，也有人在 StackOverflow 上进行了讨论 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1823306/">https://stackoverflow.com/questions/1823306/</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>不同点</th>
<th><code>order by rand()</code></th>
<th><code>where subquery</code></th>
<th><code>temporary table</code></th>
<th><code>join order by rand()</code></th>
</tr>
</thead>
<tbody><tr>
<td>可以随机获取全部</td>
<td>可以</td>
<td>几乎不可能</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>极快</td>
<td>较快</td>
<td>极快</td>
</tr>
<tr>
<td>需要可比较的主键类型</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>受数据分布密度影响</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>速度受表数据复杂度影响</td>
<td>很大</td>
<td>极小</td>
<td>较小</td>
<td>极小</td>
</tr>
</tbody></table>
<p>那么，看完上面的不同点对比，我们也可以得出它们的使用场景了</p>
<ul>
<li>强烈推荐首选 <code>join order by rand()</code> 作为随机获取数据的解决方案</li>
<li>唯一不推荐的就是 <code>order by rand()</code>，这是新手才会写出来 sql。当然，如果你的数据量很小（1000 条以下）时，直接使用 <code>order by rand()</code> 以现代机器的性能 sql 也不会很慢呢</li>
</ul>
<blockquote>
<p>注：如果仅仅只是需要打乱数据顺序的话还是更推荐将数据读取到内存中在进行操作更好！</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/18/0540dc0bb40e41c58e19c3b827aba1cd/" data-id="ckmcqox22000b0kuvbtfhaobv" data-title="MySQL 获取随机条数据" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sql/" rel="tag">sql</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/" rel="tag">electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/" rel="tag">grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jetbrains/" rel="tag">jetbrains</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webstorm/" rel="tag">webstorm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AC%E5%8F%B8/" rel="tag">公司</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A3%E5%91%8A/" rel="tag">宣告</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90/" rel="tag">开源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" rel="tag">待更新</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C/" rel="tag">经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 12.14px;">css</a> <a href="/tags/electron/" style="font-size: 15.71px;">electron</a> <a href="/tags/git/" style="font-size: 12.86px;">git</a> <a href="/tags/grid/" style="font-size: 10.71px;">grid</a> <a href="/tags/java/" style="font-size: 19.29px;">java</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jetbrains/" style="font-size: 12.14px;">jetbrains</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/markdown/" style="font-size: 10.71px;">markdown</a> <a href="/tags/react/" style="font-size: 14.29px;">react</a> <a href="/tags/sql/" style="font-size: 14.29px;">sql</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vscode/" style="font-size: 12.86px;">vscode</a> <a href="/tags/vue/" style="font-size: 16.43px;">vue</a> <a href="/tags/webstorm/" style="font-size: 10px;">webstorm</a> <a href="/tags/windows/" style="font-size: 17.14px;">windows</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 12.86px;">个人</a> <a href="/tags/%E5%85%AC%E5%8F%B8/" style="font-size: 10px;">公司</a> <a href="/tags/%E5%91%A8%E6%8A%A5/" style="font-size: 10px;">周报</a> <a href="/tags/%E5%AE%A3%E5%91%8A/" style="font-size: 10px;">宣告</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.57px;">工具</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 17.86px;">工程化</a> <a href="/tags/%E5%BC%80%E6%BA%90/" style="font-size: 10px;">开源</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" style="font-size: 15px;">异步</a> <a href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" style="font-size: 10.71px;">待更新</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 18.57px;">杂谈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 11.43px;">经验</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 12.14px;">读书</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 11.43px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/14/8fb2d58463ae4191ac064a76e15bffbd/">2021 第十周</a>
          </li>
        
          <li>
            <a href="/2021/03/12/7e7131c07c984d928ba3fefa7a9cef06/">读书-[颓废与沉默：透视犬儒文化]</a>
          </li>
        
          <li>
            <a href="/2021/03/02/db74e6e5d2444bc3b6e185a7b338bbf6/">electron 开发经验之谈系列-在渲染、主进程间共享数据</a>
          </li>
        
          <li>
            <a href="/2021/02/27/06cb464179cf45c598208534705aae3c/">2020 吾辈在公司推动的前端技术演进</a>
          </li>
        
          <li>
            <a href="/2021/02/23/cd66150d2b86448590fcc9bb2419c0b2/">实践 lerna monorepo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>