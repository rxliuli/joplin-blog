<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/18/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ccafc03fb2db486ba71f0863612aa449" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/ccafc03fb2db486ba71f0863612aa449/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/ccafc03fb2db486ba71f0863612aa449/">关于提问与帮助</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>不知从何时起，帮助别人似乎开始变成了一件吃力不讨好的事情。刚刚吾辈在 QQ 里面看到这样的几句发言，所以熬夜写了这篇内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190129232524.png" alt="受助者的发言"></p>
<p>真以为别人给予帮助是一种义务了，告诉你怎么查就是在帮助你了。<strong>总不能把饭端到你面前，却还要嚷嚷着要别人喂你吃吧？</strong><br>而且，帮助是要花费时间和精力的。很多人并不是总有时间来帮你找资料的，或许我们也只是在上班的时候想稍微休息一下，看到你的问题，就谈一下大概的解决方向而已。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>当你想要提问时，如何更加清晰的描述你的问题让别人更容易帮助你也是你的义务。不要觉得随便提问一个：<em>xx 应该怎么做？</em> 就会有人很快的回答你。吾辈个人认为提问之前最好了解下面几点</p>
<ul>
<li><strong>不要提一些容易产生争端的问题</strong><br>例如 _<code>Java</code> 和 <code>PHP</code> 哪个更好？_<br>这种问题不仅容易引战，更是毫无意义。不谈使用场合，比较则无意义。就连初中生都知道对比实验应该控制 <strong>环境变量</strong>，难道如此简单的事情你都不清楚，你是 <strong>巨婴</strong> 么？</li>
<li><strong>如果是纯粹知识性的问题最好先查询官网</strong><br>例如 <code>Spring</code> 怎么集成 <code>Mybatis</code>？<br>这种连官方文档都没过一遍就来问，就算说了也只能是鸡同鸭讲，对牛弹琴罢了。这种时候你需要的是 <strong>学习</strong> 而不是 <strong>提问</strong>。</li>
<li><strong>大部分问题已经被解决过了</strong><br>虽然不想承认，但我们的所知所想所遇已然在这个世界上重复了无数次，善用搜索引擎很重要 —— 这里吾辈只推荐 <strong>Google</strong>，不推荐的只有 <strong>百度</strong>。</li>
<li><strong>你遇到了非常冷门的问题</strong><br>那你要描述你的问题，让别人能简单的还原问题，才能更好的解决你的问题，最好附上一个可重现的 <code>github</code> 示例仓库。推荐提问的网站：国外 <a target="_blank" rel="noopener" href="https://segmentfault.com/questions">stack overflow</a>，国内 <a target="_blank" rel="noopener" href="https://segmentfault.com/questions">segmentfault</a>，提问之前可以看一下 <a target="_blank" rel="noopener" href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md">提问的智慧</a>。</li>
</ul>
<h2 id="标准示例"><a href="#标准示例" class="headerlink" title="标准示例"></a>标准示例</h2><p>下面是在 Segmentfault 提问时的简单规范</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190129233329.png" alt="Segmentfault 简单规范"></p>
<p>下面是一个简单的提问示例</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># JavaScript 中如何获取子类？</span></span><br><span class="line"></span><br><span class="line">如题，使用 es6 class 定义的类，如何获取指定基类的所有子类呢？</span><br><span class="line"></span><br><span class="line">例如下面定义了三个类 <span class="code">`A, B, C`</span></span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">class A &#123;&#125;</span></span><br><span class="line"><span class="code">class B extends A &#123;&#125;</span></span><br><span class="line"><span class="code">class C extends A &#123;&#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">吾辈如何获取到 A 的所有子类呢？(=^-ω-^=)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">有人说这个问题毫无意义，难道泥萌没有遇到过根据状态切换多种操作的情况么？难道一个一个的使用 if-else 判断会比使用 class 实现多态更优雅么？┐(￣ヮ￣)┌</span><br></pre></td></tr></table></figure>
<p>渲染之后</p>
<hr>
<h1 id="JavaScript-中如何获取子类？"><a href="#JavaScript-中如何获取子类？" class="headerlink" title="JavaScript 中如何获取子类？"></a>JavaScript 中如何获取子类？</h1><p>如题，使用 es6 class 定义的类，如何获取指定基类的所有子类呢？</p>
<p>例如下面定义了三个类 <code>A, B, C</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>吾辈如何获取到 A 的所有子类呢？(=^-ω-^=)</p>
<hr>
<p>有人说这个问题毫无意义，难道泥萌没有遇到过根据状态切换多种操作的情况么？难道一个一个的使用 if-else 判断会比使用 class 实现多态更优雅么？┐(￣ヮ￣)┌</p>
<hr>
<p>是的，这是由 <code>Markdown</code> 写出来的。作为提问者，让别人能更简单知道自己的问题是必要的，而 <code>Markdown</code> 天生的 <strong>写作语言</strong>。所以吾辈也建议使用 <code>Markdown</code> 进行提问，至少，能传递的信息要比纯文本丰富很多，不是么？</p>
<h2 id="终末"><a href="#终末" class="headerlink" title="终末"></a>终末</h2><p>最后，吾辈个人认为如果解决了问题之后，作为提问者也有必要将之分享出来，避免后人继续踩坑。分享的方式可以使用 <strong>博客</strong>，<strong>微信公众号</strong> 之类的方式，如果能将一个问题讲明白给别人听，那才说明自己懂得了如何解决这个问题！</p>
<blockquote>
<p>吾辈在 segementfault 上的提问 <a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000017910469">JavaScript 中如何获取子类？</a> 以及之后写的一篇博客 <a target="_blank" rel="noopener" href="https://blog.rxliuli.com/p/e17d1a04/">JavaScript 避免使用 if-else 的方法</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/ccafc03fb2db486ba71f0863612aa449/" data-id="ckmcqox4u008l0kuvbgnhgcwh" data-title="关于提问与帮助" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cd8a463c0a404ba594b14d48579ed064" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/cd8a463c0a404ba594b14d48579ed064/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/cd8a463c0a404ba594b14d48579ed064/">Vue 自定义标签的 src 属性不能使用相对路径</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈在使用 Vuetify 时突然遇到的，明明 <code>img</code> 标签就可以使用相对路径获取到图片，而 Veutify 的组件 <code>v-img</code> 却不能使用。</p>
<p>如下面 3 种加载图片的方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正常加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">v-img</span> <span class="attr">:src</span>=<span class="string">&quot;require(&#x27;../../assets/logo.png&#x27;)&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 无法加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">v-img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/logo.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 正常加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/logo.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>吾辈在 <a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000016871400">segmentfault</a> 上的提问</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>是的，居然必须用 <code>require()</code> 引入图片才能生效，那为什么 <code>img</code> 标签可以直接使用相对路径呢？这和 <a target="_blank" rel="noopener" href="https://vue-loader-v14.vuejs.org/zh-cn/configurations/asset-url.html">vue-loader 资源路径处理</a> 有关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181101130706.png" alt="官方资源路径处理"></p>
<p>官方明确指出会将所有资源路径作为模块依赖，也就是后台 <code>vue-loader</code> 帮我们转换成 <code>require()</code> 的形式了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="vue-cli-3"><a href="#vue-cli-3" class="headerlink" title="vue cli 3"></a>vue cli 3</h3><p>vue cli 3 的配置项 API 发生了改变，由 <code>transformToRequire</code> 改为 <code>transformAssetUrls</code>，而且配置方式也不再是直接修改 webpack 配置文件，而是修改 <code>vue.config.js</code> 这个经过包装后的文件。现在，最新的配置方式如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&quot;vue&quot;</span>)</span><br><span class="line">      .use(<span class="string">&quot;vue-loader&quot;</span>)</span><br><span class="line">      .loader(<span class="string">&quot;vue-loader&quot;</span>)</span><br><span class="line">      .tap(<span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...options,</span><br><span class="line">          <span class="comment">//修复静态资源引用的问题 vue cli 2 =&gt; vue cli 3 升级之后配置项由 transformToRequire 改为 transformAssetUrls</span></span><br><span class="line">          transformAssetUrls: &#123;</span><br><span class="line">            video: [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;poster&quot;</span>],</span><br><span class="line">            source: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">            img: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">            image: <span class="string">&quot;xlink:href&quot;</span>,</span><br><span class="line">            <span class="comment">// 在这里添加需要使用静态资源的自定义元素</span></span><br><span class="line">            <span class="string">&quot;a-avatar&quot;</span>: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>具体参考<br><a target="_blank" rel="noopener" href="https://vue-loader.vuejs.org/zh/migrating.html#%E5%BA%9F%E5%BC%83%E7%9A%84%E9%80%89%E9%A1%B9">Vue Loader =&gt; 从 v14 迁移 =&gt; 废弃的选项</a><br><a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">Vue Cli 3 =&gt; webpack 相关 =&gt; 链式操作 (高级) =&gt; 修改 Loader 选项</a></p>
</blockquote>
<h3 id="vue-cli-2"><a href="#vue-cli-2" class="headerlink" title="vue cli 2"></a>vue cli 2</h3><p>那么，Veutify 组件中的 <code>src</code> 不能使用相对路径的原因就很明确了。因为 <code>vue-loader</code> 并不知道我们要把 <code>v-img</code> 的 <code>src</code> 属性转换成 <code>require()</code> 依赖。我们找到 <code>vue-loader</code> 配置处，在 <code>options.transformToRequire</code> 中加上 <code>v-img</code> 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuetify 框架的 src 标签也需要自动转换为 require</span></span><br><span class="line"><span class="string">&#x27;v-img&#x27;</span>: <span class="string">&#x27;src&#x27;</span></span><br></pre></td></tr></table></figure>
<p>吾辈的配置文件在 <em>build &gt; vue-loader.conf.js</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">&quot;./utils&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&quot;../config&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProduction = process.env.NODE_ENV === <span class="string">&quot;production&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> sourceMapEnabled = isProduction</span><br><span class="line">  ? config.build.productionSourceMap</span><br><span class="line">  : config.dev.cssSourceMap;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  loaders: utils.cssLoaders(&#123;</span><br><span class="line">    sourceMap: sourceMapEnabled,</span><br><span class="line">    extract: isProduction,</span><br><span class="line">  &#125;),</span><br><span class="line">  cssSourceMap: sourceMapEnabled,</span><br><span class="line">  cacheBusting: config.dev.cacheBusting,</span><br><span class="line">  transformToRequire: &#123;</span><br><span class="line">    video: [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;poster&quot;</span>],</span><br><span class="line">    source: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">    img: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">    image: <span class="string">&quot;xlink:href&quot;</span>,</span><br><span class="line">    <span class="string">&quot;v-img&quot;</span>: <span class="string">&quot;src&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://vue-loader-v14.vuejs.org/zh-cn/options.html#transformtorequire">vue-loader 官方文档参考</a></p>
</blockquote>
<p>然后重启 <code>npm run dev</code> 刷新一下就行啦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/cd8a463c0a404ba594b14d48579ed064/" data-id="ckmcqox4v008p0kuvh5e49h6v" data-title="Vue 自定义标签的 src 属性不能使用相对路径" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ce80e7bf68d6471783155673cef45b36" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/ce80e7bf68d6471783155673cef45b36/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/ce80e7bf68d6471783155673cef45b36/">JavaScript 使用 fetch 上传文件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>fetch</code> 是 ES6 的一个新的特性，用来简化处理异步的 Ajax 请求。</p>
<blockquote>
<p>fetch 可以参考 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/">MDN</a> 上的教程：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></p>
</blockquote>
<p>假设后端（Java）有一个用于上传文件的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 上传文件</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> imgFile</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/uploadFile&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OperationResult <span class="title">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;imgFile&quot;)</span> MultipartFile imgFile)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前端中只要使用如下代码即可上传一个文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是用来演示的 html 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;imgFile&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#imgFile&quot;</span>).addEventListener(<span class="string">&quot;change&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个 FormData 对象</span></span><br><span class="line">  <span class="keyword">const</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">  <span class="comment">// 得到 File 对象</span></span><br><span class="line">  <span class="keyword">const</span> file = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#imgFile&quot;</span>).files[<span class="number">0</span>];</span><br><span class="line">  fd.append(<span class="string">&quot;imgFile&quot;</span>, file);</span><br><span class="line">  <span class="comment">// 这里的 url 是上传链接，此处为 /uploadFile</span></span><br><span class="line">  fetch(url, &#123;</span><br><span class="line">    method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    body: fd,</span><br><span class="line">    <span class="comment">// 注：此处不需要设置 headers</span></span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 之后的处理</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>和 <code>jquery ajax</code> 的感觉差不多，不过能实现效果就好啦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/ce80e7bf68d6471783155673cef45b36/" data-id="ckmcqox4w008t0kuv6lwmgnyb" data-title="JavaScript 使用 fetch 上传文件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-d4e81c9032974019bf96a08272608fd9" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/d4e81c9032974019bf96a08272608fd9/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/d4e81c9032974019bf96a08272608fd9/">在 VSCode 中使用路径别名也有提示</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在学 ReactJS，遇到了一个很奇怪的问题。当吾辈在 webpack 配置中配置了路径别名之后，VSCode 再输入路径便没有了提示。</p>
<p>路径别名配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  <span class="comment">// Support React Native Web</span></span><br><span class="line">  <span class="comment">// https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/</span></span><br><span class="line">  <span class="string">&#x27;react-native&#x27;</span>: <span class="string">&#x27;react-native-web&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>吾辈也安装了 <a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense">Path Intellisense</a> 插件，然而这毫无意义，仍然是只有在相对路径的情况下才会提示。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>抱着这个疑问，吾辈稍微去搜索了一下。然后，找到了 <a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000014941483">webpack 自定义别名后，VScode 路径提示问题</a> 这个问题。在下面的回答中，吾辈找到了答案。</p>
<blockquote>
<p>注：这里已采纳的答案实际上应该是复制少了一个括号导致实际使用会出错，不过确实是正确答案。</p>
</blockquote>
<p>在项目根目录下添加 <code>jsconfig.json</code> 并添加以下配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重启 VSCode，之后，一切便恢复了理想状态！</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>那么，<code>jsconfig.json</code> 到底是什么神奇的东西，为什么能影响到 VSCode 的提示呢？吾辈找到了 VSCode 官网上的文档，文档上对此的说明是：<strong>VSCode 大部分功能都是开箱即用，然而有些却需要进行一些基本的配置才能获得最佳体验，jsconfig 就是用来配置 JavaScript 语言的相关功能。</strong></p>
<p>所以，原因明了了，这是 VSCode 内置的功能，就是为了便于开发的。而我们仅仅需要做一些简单的配置，即可使用这些功能。<br>吾辈也使用 <code>tsc</code> 命令生成了一份 <code>jsconfig.json</code>（由 <code>tsconfig.json</code> 改名），泥萌可以复制并按照自己的需求修改其中的配置。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2018&quot;</span> <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;,&#x27;ES2018&#x27; or &#x27;ESNEXT&#x27;. */</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es2015&quot;</span> <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, or &#x27;ESNext&#x27;. */</span>,</span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// &quot;checkJs&quot;: true,                       /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                   /* Generates corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                     /* Generates corresponding &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="comment">// &quot;outDir&quot;: &quot;./&quot;,                        /* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;removeComments&quot;: true,                /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// &quot;noEmit&quot;: true,                        /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#x27;tslib&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enable all strict type-checking options. */</span>,</span><br><span class="line">    <span class="comment">// &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span> <span class="comment">/* Base directory to resolve non-absolute module names. */</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>]</span><br><span class="line">    &#125; <span class="comment">/* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span>,</span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span> <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/d4e81c9032974019bf96a08272608fd9/" data-id="ckmcqox4x008v0kuv4uy3fbyq" data-title="在 VSCode 中使用路径别名也有提示" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-d5ae689f677a41bd8e1281f6b36cf55e" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/d5ae689f677a41bd8e1281f6b36cf55e/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/d5ae689f677a41bd8e1281f6b36cf55e/">JavaScript 加载全部资源后再使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>客户需要一次性将视频全部缓冲完成再进行观看而非看一段缓冲一段，所以就看了一下有没有什么方法能够做到，结果顺便还写了一个通用的加载资源的方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基本思路是使用 <code>ajax</code>(<code>fetch</code>) 将资源先加载到本地，然后生成一个本地的 url，最后将本地资源链接赋值给需要资源的元素上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 url 中的内容加载到元素上</span></span><br><span class="line"><span class="comment"> * 注：domSelector 必须有 src 属性用以将加载完成的资源赋值给其，加载默认是异步的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>url url 资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;document&#125;</span> </span>domSelector dom 选择器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>init 初始化参数, 实为 fetch() 的参数以及一些自定义的参数</span></span><br><span class="line"><span class="comment"> * 关于 fetch 具体可以参考 &lt;https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch&gt;</span></span><br><span class="line"><span class="comment"> * 自定义的参数有:</span></span><br><span class="line"><span class="comment"> * before: 加载之前的方法，例如可以设置一个弹窗或者遮罩告诉用户资源正在加载中</span></span><br><span class="line"><span class="comment"> * after: 加载完成之后的方法，例如可以设置一个加载完成的动画提醒一下用户</span></span><br><span class="line"><span class="comment"> * error: 发生异常时的方法，例如可以设置一个错误提示通知用户加载异常需要刷新了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadResource</span>(<span class="params">url, domSelector, init</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">    init = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (init.before &amp;&amp; <span class="keyword">typeof</span> init.before === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    init.before();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有自定义缓存的话就设置缓存</span></span><br><span class="line">  init.cache = init.cache || <span class="string">&quot;force-cache&quot;</span>;</span><br><span class="line">  <span class="comment">// 如果没有自定义错误处理就设置一下错误处理</span></span><br><span class="line">  init.error =</span><br><span class="line">    init.error || (<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`request was wrong: <span class="subst">$&#123;error&#125;</span>`</span>));</span><br><span class="line">  fetch(url, init)</span><br><span class="line">    <span class="comment">// 判断返回的状态是否正常</span></span><br><span class="line">    .then(<span class="function">(<span class="params">rep</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (rep.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rep;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`response status error <span class="subst">$&#123;rep.status&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 转换资源</span></span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> data.blob())</span><br><span class="line">    .then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生成一个本地的 url 并赋值给 src 属性</span></span><br><span class="line">      domSelector.src = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">      <span class="keyword">if</span> (init.after &amp;&amp; <span class="keyword">typeof</span> init.after === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        init.after();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(init.error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>假如有一个 <code>video</code> 元素需要加载视频</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;video&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么使用该方法的 <code>JavaScript</code> 代码就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要加载的 url 资源</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;/html/testVideo.m4&quot;</span>;</span><br><span class="line"><span class="comment">// 资源的容器，这里是一个视频元素</span></span><br><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#video&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处使用第三个参数仅为演示，不需要的话忽略即可。。。</span></span><br><span class="line">loadResource(url, video, &#123;</span><br><span class="line">  before: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;video load before&quot;</span>),</span><br><span class="line">  after: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;video load after&quot;</span>),</span><br><span class="line">  error: <span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`video load error: <span class="subst">$&#123;error&#125;</span>`</span>),</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 即可以：</span></span><br><span class="line">loadResource(url, video);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：此方法不仅可以加载视频，也可以加载 audio, img 等拥有 src 属性的二进制资源</p>
<p>这个方法同样也已经丢到了 <a target="_blank" rel="noopener" href="https://gist.github.com/rxliuli/1bf04abd0e91718a901b97762beb0eb9">GitHub Gist</a> 上面啦</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/d5ae689f677a41bd8e1281f6b36cf55e/" data-id="ckmcqox4y008z0kuvczgb8l6f" data-title="JavaScript 加载全部资源后再使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-db2c1059578c496a90628f9af942e3db" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/db2c1059578c496a90628f9af942e3db/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/db2c1059578c496a90628f9af942e3db/">Git Push 提示不支持具有 Socks5 方案的代理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>使用 <code>Git Push</code> 提交代码到远程服务器时提示了一个错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: NotSupportedException encountered.</span><br><span class="line">   ServicePointManager 不支持具有 socks5 方案的代理。</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>然而之后还是正常提交成功了，实际上问题是：</p>
<ol>
<li> 配置了本地的 <code>socks5</code> 的代理（<code>Shadowsocks</code> 之类的代理软件）</li>
<li> 配置了远程服务器 <code>Git</code> 服务端的 <code>SSH</code></li>
<li> 本地提交代码到远程服务器时使用的是 <code>http/https</code> 协议</li>
</ol>
<p>这三者只要有一个不满足就不会出现这个错误了</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li><p>取消代理<br> 使用以下简单命令即可取消代理</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：取消代理会出现另外一个错误，所以并不能解决实际问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>取消远程的 <code>SSH</code><br> 在下面的页面中删除你的 <code>SSH Keys</code> 即可</p>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/settings/keys">GitHub</a></li>
<li><a target="_blank" rel="noopener" href="https://bitbucket.org/account/user/your_username/ssh-keys/">Bitbucket</a></li>
</ul>
</blockquote>
</li>
<li><p>提交内容到远程 <code>Git</code> 服务器时选择 <code>SSH</code> 协议<br> 设置远程仓库为 <code>SSH</code> 协议，例如 <code>GitHub</code> 的 <code>SSH</code> 链接就是 &lt;<a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:rxliuli/rxliuli.github.io.git&gt;</p>
</li>
</ol>
<p>好了，关于 <code>Git</code> 提示错误 <em>Git Push 提示不支持具有 Socks5 方案的代理</em> 就到这里啦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/db2c1059578c496a90628f9af942e3db/" data-id="ckmcqox51009b0kuvap7d0xhz" data-title="Git Push 提示不支持具有 Socks5 方案的代理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-f1a15a514a6a4c0488a96062a139221d" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/f1a15a514a6a4c0488a96062a139221d/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/f1a15a514a6a4c0488a96062a139221d/">Greasemonkey 踩坑之路</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#greasemonkey-%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF">Greasemonkey 踩坑之路</a><ul>
<li><a href="#%E5%9C%BA%E6%99%AF">场景</a></li>
<li><a href="#window-%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E5%92%8C%E5%A4%96%E9%83%A8%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE">window 对象不能和外部交换数据</a></li>
<li><a href="#greasemonkey-api-%E6%98%BE%E7%A4%BA-undefined">Greasemonkey API 显示 undefined</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E7%88%86%E7%82%B8">内存爆炸</a></li>
<li><a href="#greasemonkey-%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA%E5%A4%AA%E6%99%9A">Greasemonkey 加载时机太晚</a><ul>
<li><a href="#%E7%AD%89%E5%BE%85%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%8D%E8%B0%83%E7%94%A8%E4%BE%8B%E5%A6%82%E7%AD%89%E4%B8%AA%E5%87%A0%E7%A7%92-greasemonkey-%E8%84%9A%E6%9C%AC%E5%8F%AF%E8%83%BD%E5%B0%B1%E5%8A%A0%E8%BD%BD%E4%BA%86">等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E5%88%B0-greasemonkey-%E8%84%9A%E6%9C%AC%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%86%8D%E4%B8%8E%E4%B9%8B%E4%BA%A4%E4%BA%92">延迟到 Greasemonkey 脚本加载完成再与之交互</a></li>
<li><a href="#%E6%9A%B4%E9%9C%B2%E5%87%BA%E9%9C%80%E8%A6%81%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%89%E5%88%B0-greasemonkey-%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%BF%9B%E8%A1%8C%E5%9B%9E%E8%B0%83">暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在玩 Greasemonkey 脚本，遇到了各种奇怪的问题，便于此处统一记录一下。</p>
<h2 id="window-对象不能和外部交换数据"><a href="#window-对象不能和外部交换数据" class="headerlink" title="window 对象不能和外部交换数据"></a>window 对象不能和外部交换数据</h2><p>场景</p>
<p>在写 Greasemonkey 脚本时遇到的一个奇怪的问题，吾辈想要把某些数据添加到 <code>window</code> 对象上，方便在 DevTool console 中进行测试。然而却由此印发了一个新的问题，即 <code>window</code> 对象不是真正的 <code>window</code> 对象的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Testing</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  用来测试的 userjs 脚本</span></span><br><span class="line"><span class="comment">// @author       rxliuli</span></span><br><span class="line"><span class="comment">// @include     http://*</span></span><br><span class="line"><span class="comment">// @include			https://*</span></span><br><span class="line"><span class="comment">// @grant        MIT</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.rxliuli = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;这里是 rxliuli 编写的 user.js 脚本&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">window</span>.rxliuli();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>控制台正常输出了一句话。然而，当吾辈在 console 中输入 <code>window.rxliuli</code> 的结果却是 <code>undefined</code>。</p>
<hr>
<p>解决</p>
<p>吾辈估计又是 Greasemonkey 自身的问题，所以不得不去翻了 <a target="_blank" rel="noopener" href="https://wiki.greasespot.net/">Wiki</a> 上查找，直到看到了 <a target="_blank" rel="noopener" href="https://wiki.greasespot.net/Greasemonkey_Manual:Environment">Greasemonkey Manual:Environment</a>。里面有这么一段话</p>
<blockquote>
<p>Depending on the usage, the special Greasemonkey environment may seem perfectly normal, or excessively limiting.<br>The Greasemonkey environment is a vanilla XPCNativeWrapper of the content window, with only certain extra bits added in to emulate a normal environment, or changed. Specifically:</p>
<ul>
<li>window is an XPCNativeWrapper of the content window.</li>
<li>document is the document object of the XPCNativeWrapper window object.</li>
<li>XPathResult is added so that document.evaluate() works.</li>
<li>Unless the @unwrap metadata imperative is present in the user script header, the entire script is wrapped inside an anonymous function, to guarantee the script’s identifiers do not collide with identifiers present in the Mozilla JavaScript sandbox. This function wrapper captures any function definitions and var variable declarations made (e.g. var i = 5;) into the function’s local scope. Declarations made without var will however end up on the script’s this object, which in Greasemonkey is the global object, contrary to in the normal browser object model, where the window object fills this function. In effect, after i = 5;, the values of window[‘i’] and window.i remain undefined, whereas this[‘i’] and this.i will be 5. See also: Global object</li>
<li>In order to access variables on the page, use the unsafeWindow object. To use values defined in a script, simply reference them by their names.</li>
</ul>
</blockquote>
<p>大意是 Greasemonkey 为了安全所以 Greasemonkey 脚本是在沙箱中执行的，并且限制了一些内容。其中就包括了 <code>window</code> 对象并非浏览器的原生对象，而是 <code>XPCNativeWrapper</code>。<br>所以，<code>XPCNativeWrapper</code> 是什么。。。？（一个 Greasemonkey 的坑太多了吧 #吐血）<br>吾辈找到了两篇文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-TW/docs/XPCNativeWrapper">XPCNat ive Wrapper</a></li>
<li><a target="_blank" rel="noopener" href="http://kb.mozillazine.org/XPCNativeWrapper">Use XPCNativeWrapper</a></li>
</ul>
<p>看完之后表示只知道 <code>XPCNativeWrapper</code> 是在扩展中用来保护不受信任的对象，并非浏览器客户端本身的 API。</p>
<p>好吧，说了这么多解决方案是什么呢？</p>
<p>答案很简单，其实使用 <a target="_blank" rel="noopener" href="https://wiki.greasespot.net/UnsafeWindow">unsafeWindow</a> 对象就能像使用原生的 <code>window</code> 对象行为一致，即便这是不推荐的方法，但有时仍然是必须的！</p>
<h2 id="Greasemonkey-API-显示-undefined"><a href="#Greasemonkey-API-显示-undefined" class="headerlink" title="Greasemonkey API 显示 undefined"></a>Greasemonkey API 显示 undefined</h2><p>场景</p>
<p>在 <a target="_blank" rel="noopener" href="https://wiki.greasespot.net/Greasemonkey_Manual:API">Greasemonkey 手册：API</a> 写出的 API 有很多都不能正常使用，吾辈打印下来的结果是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         test</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  test</span></span><br><span class="line"><span class="comment">// @match        *</span></span><br><span class="line"><span class="comment">// @author       rxliuli</span></span><br><span class="line"><span class="comment">// @grant        MIT</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(GM);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.info);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.deleteValue);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.getValue);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.listValues);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.setValue);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.getResourceUrl);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.notification);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.openInTab);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.setClipboard);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.setClipboard);</span><br><span class="line">  <span class="built_in">console</span>.log(unsafeWindow);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181219225309.png" alt="Greasemonkey API 显示 undefined"></p>
<p>测试环境如下：</p>
<ul>
<li>Windows 10 Ltsc</li>
<li>Chrome 71</li>
<li>tampermonkey 4.7.44</li>
</ul>
<hr>
<p>解决</p>
<p>吾辈在翻 <a target="_blank" rel="noopener" href="https://github.com/sindresorhus/globals/issues/122">GitHub Issue</a> 找到了问题所在，原因是这些 API 必须要手动获取准许才行。<br>即使用 <code>// @grant GM.[Function]</code> 来获取需要的 API，所以吾辈的脚本变成了下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         test</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  test</span></span><br><span class="line"><span class="comment">// @match        *</span></span><br><span class="line"><span class="comment">// @author       rxliuli</span></span><br><span class="line"><span class="comment">// @grant        MIT</span></span><br><span class="line"><span class="comment">// @grant        GM.deleteValue</span></span><br><span class="line"><span class="comment">// @grant        GM.getValue</span></span><br><span class="line"><span class="comment">// @grant        GM.listValues</span></span><br><span class="line"><span class="comment">// @grant        GM.setValue</span></span><br><span class="line"><span class="comment">// @grant        GM.getResourceUrl</span></span><br><span class="line"><span class="comment">// @grant        GM.notification</span></span><br><span class="line"><span class="comment">// @grant        GM.openInTab</span></span><br><span class="line"><span class="comment">// @grant        GM.setClipboard</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(GM);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.info);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.deleteValue);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.getValue);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.listValues);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.setValue);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.getResourceUrl);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.notification);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.openInTab);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.setClipboard);</span><br><span class="line">  <span class="built_in">console</span>.log(GM.setClipboard);</span><br><span class="line">  <span class="built_in">console</span>.log(unsafeWindow);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>问题解决了，现在，所有的 API 都有值了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181219225919.png" alt="GM API 都有值了"></p>
<h2 id="内存爆炸"><a href="#内存爆炸" class="headerlink" title="内存爆炸"></a>内存爆炸</h2><p>场景</p>
<p>使用了 <code>GM.setValue()/GM.getValue()</code> 两个 API，结果内存分分钟爆炸。吾辈安装 Chrome 以来第一次碰到加载网页能把内存耗尽的情况，果然 GM 的限制不是没有道理的呢<br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181220002112.png" alt="内存爆炸"><br><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181220013001.png" alt="浏览器崩溃"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Testing</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @match        *</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  用来测试的 userjs 脚本</span></span><br><span class="line"><span class="comment">// @author       rxliuli</span></span><br><span class="line"><span class="comment">// @grant        GM.getValue</span></span><br><span class="line"><span class="comment">// @grant        GM.setValue</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> domains = &#123;</span><br><span class="line">    domainsName: <span class="string">&quot;domains&quot;</span>,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">list</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> valueStr = GM.getValue(<span class="built_in">this</span>.domainsName);</span><br><span class="line">      <span class="keyword">if</span> (!valueStr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(valueStr);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">var</span> defaultArr = [];</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.set(defaultArr);</span><br><span class="line">        <span class="keyword">return</span> defaultArr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">set</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> GM.setValue(<span class="built_in">this</span>.domainsName, <span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.list();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> domains.set(arr);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<hr>
<p>解决</p>
<p>Debug 之后发现是调用 <code>GM.setValue()</code> 没有使用 <code>await</code> 造成的异步请求数量不断积累最终导致网页崩溃。果然 Promise 什么的还是要小心一点好呀<br>当然，不信的话你也可以新建一个 Greasemonkey 脚本尝试一下内存爆炸的感觉咯</p>
<blockquote>
<p>递归不是主要问题，吾辈 PC 上的 Chrome 最多到 1.4w+ 次递归就会抛出异常（网页没有崩溃），还没到 1.4w+ 次，所以说递归不是主要问题呀</p>
</blockquote>
<h2 id="Greasemonkey-加载时机太晚"><a href="#Greasemonkey-加载时机太晚" class="headerlink" title="Greasemonkey 加载时机太晚"></a>Greasemonkey 加载时机太晚</h2><p>场景</p>
<p>Greasemonkey 的加载是在页面加载完毕时，类似于 <code>window.onload</code>，所以造成了一个问题：如果想要在网站的 JavaScript 代码中与 Greasemonkey 脚本交互，那么必须要等到 Greasemonkey 加载完成，而加载完成的时机是不确定的。</p>
<p>吾辈目前想要的解决方案有三种</p>
<h3 id="等待一段时间再调用，例如等个几秒-Greasemonkey-脚本可能就加载了"><a href="#等待一段时间再调用，例如等个几秒-Greasemonkey-脚本可能就加载了" class="headerlink" title="等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了"></a>等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了</h3><p>思路</p>
<p>现在没有人，我等会再来问一次！</p>
<p>实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wait = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现和调用最为简单，但无法保证等待之后就一定能获得资源了</span></span><br><span class="line">wait(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(完成));</span><br></pre></td></tr></table></figure>
<h3 id="延迟到-Greasemonkey-脚本加载完成再与之交互"><a href="#延迟到-Greasemonkey-脚本加载完成再与之交互" class="headerlink" title="延迟到 Greasemonkey 脚本加载完成再与之交互"></a>延迟到 Greasemonkey 脚本加载完成再与之交互</h3><p>思路</p>
<p>有人吗? 没有的话我等会再来问！</p>
<p>实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询等待指定资源加载完毕再执行操作</span></span><br><span class="line"><span class="comment"> * 使用 Promises 实现，可以使用 ES7 的 &#123;<span class="doctag">@async</span>&#125;/&#123;<span class="doctag">@await</span>&#125; 调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>resourceFn 判断必须的资源是否存在的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>options 选项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitResource</span>(<span class="params">resourceFn, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> optionsRes = <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      interval: <span class="number">1000</span>,</span><br><span class="line">      max: <span class="number">10</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    options</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">var</span> current = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resourceFn()) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;</span><br><span class="line">      current++;</span><br><span class="line">      <span class="keyword">if</span> (current &gt;= optionsRes.max) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        reject(<span class="string">&quot;等待超时&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, optionsRes.interval);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resourceFn = (<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第 <span class="subst">$&#123;i++&#125;</span> 次调用`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;)(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">waitResource(resourceFn, &#123;</span><br><span class="line">  interval: <span class="number">1000</span>,</span><br><span class="line">  max: <span class="number">3</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;完成&quot;</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>
<h3 id="暴露出需要交互的函数等到-Greasemonkey-加载完成后进行回调"><a href="#暴露出需要交互的函数等到-Greasemonkey-加载完成后进行回调" class="headerlink" title="暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调"></a>暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调</h3><p>思路</p>
<p>现在没有人，有人的时候再叫我！</p>
<p>实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>ms 超时毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>name 准备被调用的挂载到 window 对象上的方法名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitingToCall</span>(<span class="params">ms, name = <span class="string">&quot;waiting&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;等待超时&quot;</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">    <span class="built_in">window</span>[name] = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waitingToCall(<span class="number">3000</span>, <span class="string">&quot;waiting&quot;</span>)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;完成&quot;</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/f1a15a514a6a4c0488a96062a139221d/" data-id="ckmcqox5900a10kuv1kkx7scd" data-title="Greasemonkey 踩坑之路" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C/" rel="tag">经验</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-f1b5596efdf14c3688ed6b99b5abaee0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/f1b5596efdf14c3688ed6b99b5abaee0/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/f1b5596efdf14c3688ed6b99b5abaee0/">JavaScript 自定义限流队列 fetch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么需要它"><a href="#为什么需要它" class="headerlink" title="为什么需要它"></a>为什么需要它</h2><p>有些时候不得不需要限制并发 fetch 的请求数量，避免请求过快导致 IP 封禁</p>
<h2 id="需要做到什么"><a href="#需要做到什么" class="headerlink" title="需要做到什么"></a>需要做到什么</h2><ul>
<li>允许限制 fetch 请求同时存在的数量</li>
<li>时间过久便认为是超时了</li>
</ul>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="暂停请求"><a href="#暂停请求" class="headerlink" title="暂停请求"></a>暂停请求</h3><blockquote>
<p>该方法的请求是无序的！</p>
</blockquote>
<ol>
<li> 使用 class 定义默认超时设置和请求数量限制的构造函数</li>
<li>在请求前判断当前请求的数量，添加请求等待数量<ol>
<li> 如果请求数量已满，则进行等待</li>
<li> 如果请求数量未满，则删除一个请求等待数量</li>
</ol>
</li>
<li> 请求完成，删除当前请求数量</li>
</ol>
<h3 id="等待队列：循环监听"><a href="#等待队列：循环监听" class="headerlink" title="等待队列：循环监听"></a>等待队列：循环监听</h3><blockquote>
<p>该方法需要使用回调函数</p>
</blockquote>
<ol>
<li> 使用 class 定义默认超时设置和请求数量限制的构造函数</li>
<li> 在请求前将请求 argments 添加到等待队列中</li>
<li>使用 <code>setInterval</code> 函数持续监听队列和当前执行的请求数<ul>
<li>发现请求数量没有到达最大值，且等待队列中还有值，那么就执行一次请求</li>
</ul>
</li>
</ol>
<h3 id="等待队列：触发钩子"><a href="#等待队列：触发钩子" class="headerlink" title="等待队列：触发钩子"></a>等待队列：触发钩子</h3><ol>
<li> 使用 class 定义默认超时设置和请求数量限制的构造函数</li>
<li> 在请求前将请求 argments 添加到等待队列中</li>
<li> 添加完成，等待当前请求数量未满</li>
<li> 尝试启动等待队列（钩子）</li>
</ol>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="暂停请求实现"><a href="#暂停请求实现" class="headerlink" title="暂停请求实现"></a>暂停请求实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 fetch 请求添加超时选项</span></span><br><span class="line"><span class="comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTimeout</span>(<span class="params">fetchPromise, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> abortFn = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//这是一个可以被reject的promise</span></span><br><span class="line">  <span class="keyword">var</span> abortPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    abortFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;abort promise&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> abortablePromise = <span class="built_in">Promise</span>.race([fetchPromise, abortPromise]);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    abortFn();</span><br><span class="line">  &#125;, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> abortablePromise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限制并发请求数量的 fetch 封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestLimiting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; timeout = <span class="number">10000</span>, limit = <span class="number">10</span> &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.execCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.waitCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行一个请求</span></span><br><span class="line"><span class="comment">   * 如果到达最大并发限制时就进行等待</span></span><br><span class="line"><span class="comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">_fetch</span>(<span class="params">url, init</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.waitCount++;</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> <span class="built_in">this</span>.execCount &lt; <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="built_in">this</span>.waitCount--;</span><br><span class="line">    <span class="built_in">this</span>.execCount++;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> promiseTimeout(fetch(url, init), <span class="built_in">this</span>.timeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.execCount--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestLimiting = <span class="keyword">new</span> RequestLimiting(&#123; <span class="attr">timeout</span>: <span class="number">500</span>, <span class="attr">limit</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>).fill(<span class="number">0</span>).forEach(<span class="function">(<span class="params">i</span>) =&gt;</span></span><br><span class="line">  requestLimiting</span><br><span class="line">    ._fetch(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="等待队列：循环监听实现"><a href="#等待队列：循环监听实现" class="headerlink" title="等待队列：循环监听实现"></a>等待队列：循环监听实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 fetch 请求添加超时选项</span></span><br><span class="line"><span class="comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTimeout</span>(<span class="params">fetchPromise, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> abortFn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是一个可以被reject的promise</span></span><br><span class="line">  <span class="keyword">var</span> abortPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    abortFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;abort promise&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> abortablePromise = <span class="built_in">Promise</span>.race([fetchPromise, abortPromise]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    abortFn();</span><br><span class="line">  &#125;, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> abortablePromise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限制并发请求数量的 fetch 封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestLimiting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; timeout = <span class="number">10000</span>, limit = <span class="number">10</span> &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.execCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待队列</span></span><br><span class="line">    <span class="built_in">this</span>.waitArr = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视 execCount 的值</span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.execCount &gt;= <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.debug(</span><br><span class="line">        <span class="string">`执行 execCount: <span class="subst">$&#123;<span class="built_in">this</span>.execCount&#125;</span>, waitArr length: <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="built_in">this</span>.waitArr.length</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>, index: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.waitArr[<span class="number">0</span>])&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">this</span>.waitArr.shift(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.execCount++;</span><br><span class="line">      <span class="keyword">const</span> callback = args[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有错误就返回 res</span></span><br><span class="line">        callback(&#123; <span class="attr">res</span>: <span class="keyword">await</span> promiseTimeout(fetch(...args), <span class="built_in">this</span>.timeout) &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 否则返回 err</span></span><br><span class="line">        callback(&#123;</span><br><span class="line">          err: err,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.execCount--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行一个请求</span></span><br><span class="line"><span class="comment">   * 如果到达最大并发限制时就进行等待</span></span><br><span class="line"><span class="comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">_fetch</span>(<span class="params">url, init, callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.waitArr.push(<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestLimiting = <span class="keyword">new</span> RequestLimiting(&#123; <span class="attr">timeout</span>: <span class="number">500</span>, <span class="attr">limit</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>).fill(<span class="number">0</span>).forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span></span><br><span class="line">  requestLimiting._fetch(</span><br><span class="line">    <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 这里设置添加时的 index，用于验证是否真的顺序执行了</span></span><br><span class="line">      headers: &#123;</span><br><span class="line">        index: i,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这里使用了回调函数，参数使用解构得到</span></span><br><span class="line">    (&#123; res, err &#125;) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`res: <span class="subst">$&#123;res&#125;</span>, err: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="等待队列：触发钩子实现"><a href="#等待队列：触发钩子实现" class="headerlink" title="等待队列：触发钩子实现"></a>等待队列：触发钩子实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 fetch 请求添加超时选项</span></span><br><span class="line"><span class="comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTimeout</span>(<span class="params">fetchPromise, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> abortFn = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//这是一个可以被 reject 的 Promise</span></span><br><span class="line">  <span class="keyword">var</span> abortPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    abortFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;abort promise&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 有一个 Promise 完成就立刻结束</span></span><br><span class="line">  <span class="keyword">var</span> abortablePromise = <span class="built_in">Promise</span>.race([fetchPromise, abortPromise]);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    abortFn();</span><br><span class="line">  &#125;, timeout);</span><br><span class="line">  <span class="keyword">return</span> abortablePromise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限制并发请求数量的 fetch 封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestLimiting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; timeout = <span class="number">10000</span>, limit = <span class="number">10</span> &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.execCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待队列</span></span><br><span class="line">    <span class="built_in">this</span>.waitArr = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行一个请求</span></span><br><span class="line"><span class="comment">   * 如果到达最大并发限制时就进行等待</span></span><br><span class="line"><span class="comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">_fetch</span>(<span class="params">url, init</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> _innerFetch = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`执行 execCount: <span class="subst">$&#123;<span class="built_in">this</span>.execCount&#125;</span>, waitArr length: <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="built_in">this</span>.waitArr.length</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>, index: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.waitArr[<span class="number">0</span>])&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">this</span>.execCount++;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">this</span>.waitArr.shift(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> promiseTimeout(fetch(...args), <span class="built_in">this</span>.timeout);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.execCount--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.waitArr.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> <span class="built_in">this</span>.execCount &lt; <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="comment">// 尝试启动等待队列</span></span><br><span class="line">    <span class="keyword">return</span> _innerFetch();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestLimiting = <span class="keyword">new</span> RequestLimiting(&#123; <span class="attr">timeout</span>: <span class="number">500</span>, <span class="attr">limit</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>).fill(<span class="number">0</span>).forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span></span><br><span class="line">  requestLimiting</span><br><span class="line">    ._fetch(<span class="string">&quot;/&quot;</span>, &#123;</span><br><span class="line">      <span class="comment">// 这里设置添加时的 index，用于验证是否真的顺序执行了</span></span><br><span class="line">      headers: &#123;</span><br><span class="line">        index: i,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前而言，最后一种实现是最好的，同时实现了两种规范</p>
<ul>
<li>返回 <code>Promise</code>，避免使用回调函数</li>
<li>请求执行与添加顺序相同</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/f1b5596efdf14c3688ed6b99b5abaee0/" data-id="ckmcqox5a00a30kuvcm1n0t35" data-title="JavaScript 自定义限流队列 fetch" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-fa132fa479714abd999dc421ca971e1c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/fa132fa479714abd999dc421ca971e1c/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/fa132fa479714abd999dc421ca971e1c/">JavaScript 异步时序问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p>死后我们必升天堂，因为活时我们已在地狱。</p>
</blockquote>
<p>不知你是否遇到过，向后台发送了多次异步请求，结果最后显示的数据却并不正确 – 是旧的数据。</p>
<p>具体情况:</p>
<ol>
<li> 用户触发事件，发送了第 1 次请求</li>
<li> 用户触发事件，发送了第 2 次请求</li>
<li> 第 2 次请求成功，更新页面上的数据</li>
<li> 第 1 次请求成功，更新页面上的数据</li>
</ol>
<p>嗯？是不是感觉到异常了？这便是多次异步请求时会遇到的异步回调顺序与调用顺序不同的问题。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>为什么会出现这种问题？</li>
<li>出现这种问题怎么解决？</li>
</ul>
<h3 id="为什么会出现这种问题？"><a href="#为什么会出现这种问题？" class="headerlink" title="为什么会出现这种问题？"></a>为什么会出现这种问题？</h3><p>JavaScript 随处可见异步，但实际上并不是那么好控制。用户与 UI 交互，触发事件及其对应的处理函数，函数执行异步操作（网络请求），<strong>异步操作得到结果的时间（顺序）是不确定的</strong>，所以响应到 UI 上的时间就不确定，<strong>如果触发事件的频率较高/异步操作的时间过长</strong>，就会造成前面的异步操作结果覆盖后面的异步操作结果。</p>
<p>关键点</p>
<ul>
<li>异步操作得到结果的时间（顺序）是不确定的</li>
<li>如果触发事件的频率较高/异步操作的时间过长</li>
</ul>
<h3 id="出现这种问题怎么解决？"><a href="#出现这种问题怎么解决？" class="headerlink" title="出现这种问题怎么解决？"></a>出现这种问题怎么解决？</h3><p>既然关键点由两个要素组成，那么，只要破坏了任意一个即可。</p>
<ul>
<li>手动控制异步返回结果的顺序</li>
<li>降低触发频率并限制异步超时时间</li>
</ul>
<h2 id="手动控制返回结果的顺序"><a href="#手动控制返回结果的顺序" class="headerlink" title="手动控制返回结果的顺序"></a>手动控制返回结果的顺序</h2><p>根据对异步操作结果处理情况的不同也有三种不同的思路</p>
<ol>
<li> 后面异步操作得到结果后<strong>等待</strong>前面的异步操作返回结果</li>
<li> 后面异步操作得到结果后<strong>放弃</strong>前面的异步操作返回结果</li>
<li> 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个</li>
</ol>
<p>这里先引入一个公共的 <code>wait</code> 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * 如果未指定等待条件则立刻执行</span></span><br><span class="line"><span class="comment"> * 注: 此实现在 nodejs 10- 会存在宏任务与微任务的问题，切记 async-await 本质上还是 Promise 的语法糖，实际上并非真正的同步函数！！！即便在浏览器，也不要依赖于这种特性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-后面异步操作得到结果后等待前面的异步操作返回结果"><a href="#1-后面异步操作得到结果后等待前面的异步操作返回结果" class="headerlink" title="1. 后面异步操作得到结果后等待前面的异步操作返回结果"></a>1. 后面异步操作得到结果后<strong>等待</strong>前面的异步操作返回结果</h3><ol>
<li> 为每一次的异步调用都声称一个唯一 id</li>
<li> 使用列表记录所有的异步 id</li>
<li> 在真正调用异步操作后，添加一个唯一 id</li>
<li> 判断上一个正在执行的异步操作是否完成</li>
<li> 如果未完成等待上一个异步操作完成，否则直接跳过</li>
<li> 从列表中删除掉当前的 id</li>
<li> 最后等待异步操作然后返回结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个异步函数包装为具有时序的异步函数</span></span><br><span class="line"><span class="comment"> * 注: 该函数会按照调用顺序依次返回结果，后面的调用的结果需要等待前面的，所以如果不关心过时的结果，请使用 &#123;<span class="doctag">@link </span>switchMap&#125; 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 一个普通的异步函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>包装后的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeMap</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前执行的异步操作 id</span></span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 所执行的异步操作 id 列表</span></span><br><span class="line">  <span class="keyword">const</span> ids = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(fn, &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">apply</span>(<span class="params">_, _this, args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> prom = <span class="built_in">Reflect</span>.apply(_, _this, args);</span><br><span class="line">      <span class="keyword">const</span> temp = id;</span><br><span class="line">      ids.add(temp);</span><br><span class="line">      id++;</span><br><span class="line">      <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> !ids.has(temp - <span class="number">1</span>));</span><br><span class="line">      ids.delete(temp);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> prom;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codepen.io/rxliuli/pen/orXpEY">测试一下</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> wait(ms);</span><br><span class="line">    <span class="keyword">return</span> ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = mergeMap(get);</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    fn(<span class="number">30</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">20</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">10</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="built_in">console</span>.log(last);</span><br><span class="line">  <span class="comment">// 实际上确实执行了 3 次，结果也确实为 3 次调用参数之和</span></span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="2-后面异步操作得到结果后放弃前面的异步操作返回结果"><a href="#2-后面异步操作得到结果后放弃前面的异步操作返回结果" class="headerlink" title="2. 后面异步操作得到结果后放弃前面的异步操作返回结果"></a>2. 后面异步操作得到结果后<strong>放弃</strong>前面的异步操作返回结果</h3><ol>
<li> 为每一次的异步调用都声称一个唯一 id</li>
<li> 记录最新得到异步操作结果的 id</li>
<li> 记录最新得到的异步操作结果</li>
<li> 执行并等待返回结果</li>
<li>判断本次异步调用后面是否已经有调用出现结果了<ol>
<li> 是的话就直接返回后面的异步调用结果</li>
<li> 否则将本地异步调用 id 及其结果最为[最后的]</li>
<li> 返回这次的异步调用结果</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个异步函数包装为具有时序的异步函数</span></span><br><span class="line"><span class="comment"> * 注: 该函数会丢弃过期的异步操作结果，这样的话性能会稍稍提高（主要是响应比较快的结果会立刻生效而不必等待前面的响应结果）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 一个普通的异步函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>包装后的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">switchMap</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前执行的异步操作 id</span></span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 最后一次异步操作的 id，小于这个的操作结果会被丢弃</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 缓存最后一次异步操作的结果</span></span><br><span class="line">  <span class="keyword">let</span> cache;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(fn, &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">apply</span>(<span class="params">_, _this, args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = id;</span><br><span class="line">      id++;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">Reflect</span>.apply(_, _this, args);</span><br><span class="line">      <span class="keyword">if</span> (temp &lt; last) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">      &#125;</span><br><span class="line">      cache = res;</span><br><span class="line">      last = temp;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codepen.io/rxliuli/pen/BgNJbq">测试一下</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> wait(ms);</span><br><span class="line">    <span class="keyword">return</span> ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = switchMap(get);</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    fn(<span class="number">30</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">20</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">10</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="built_in">console</span>.log(last);</span><br><span class="line">  <span class="comment">// 实际上确实执行了 3 次，然而结果并不是 3 次调用参数之和，因为前两次的结果均被抛弃，实际上返回了最后一次发送请求的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="3-依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个"><a href="#3-依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个" class="headerlink" title="3. 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个"></a>3. 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个</h3><ol>
<li> 为每一次的异步调用都声称一个唯一 id</li>
<li> 使用列表记录所有的异步 id</li>
<li> 向列表中添加一个唯一 id</li>
<li> 判断上一个正在执行的异步操作是否完成</li>
<li> 如果未完成等待上一个异步操作完成，否则直接跳过</li>
<li> 真正调用异步操作</li>
<li> 从列表中删除掉当前的 id</li>
<li> 最后等待异步操作然后返回结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个异步函数包装为具有时序的异步函数</span></span><br><span class="line"><span class="comment"> * 注: 该函数会按照调用顺序依次返回结果，后面的执行的调用（不是调用结果）需要等待前面的，此函数适用于异步函数的内里执行也必须保证顺序时使用，否则请使用 &#123;<span class="doctag">@link </span>mergeMap&#125; 函数</span></span><br><span class="line"><span class="comment"> * 注: 该函数其实相当于调用 &#123;<span class="doctag">@code </span>asyncLimiting(fn, &#123;limit: 1&#125;)&#125; 函数</span></span><br><span class="line"><span class="comment"> * 例如即时保存文档到服务器，当然要等待上一次的请求结束才能请求下一次，不然数据库保存的数据就存在谬误了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 一个普通的异步函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>包装后的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatMap</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前执行的异步操作 id</span></span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 所执行的异步操作 id 列表</span></span><br><span class="line">  <span class="keyword">const</span> ids = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(fn, &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">apply</span>(<span class="params">_, _this, args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = id;</span><br><span class="line">      ids.add(temp);</span><br><span class="line">      id++;</span><br><span class="line">      <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> !ids.has(temp - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">const</span> prom = <span class="built_in">Reflect</span>.apply(_, _this, args);</span><br><span class="line">      ids.delete(temp);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> prom;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codepen.io/rxliuli/pen/xoGYxq">测试一下</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> wait(ms);</span><br><span class="line">    <span class="keyword">return</span> ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = concatMap(get);</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    fn(<span class="number">30</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">20</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">10</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="built_in">console</span>.log(last);</span><br><span class="line">  <span class="comment">// 实际上确实执行了 3 次，然而结果并不是 3 次调用参数之和，因为前两次的结果均被抛弃，实际上返回了最后一次发送请求的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然三个函数看似效果都差不多，但还是有所不同的。</p>
<ol>
<li> 是否允许异步操作并发？否: <code>concatMap</code>, 是: 到下一步</li>
<li> 是否需要处理旧的的结果？否: <code>switchMap</code>, 是: <code>mergeMap</code></li>
</ol>
<h2 id="降低触发频率并限制异步超时时间"><a href="#降低触发频率并限制异步超时时间" class="headerlink" title="降低触发频率并限制异步超时时间"></a>降低触发频率并限制异步超时时间</h2><p>思考一下第二种解决方式，本质上其实是 <strong>限流 + 自动超时</strong>，首先实现这两个函数。</p>
<ul>
<li>限流: 限制函数调用的频率，如果调用的频率过快则不会真正执行调用而是返回旧值</li>
<li>自动超时: 如果到了超时时间，即便函数还未得到结果，也会自动超时并抛出错误</li>
</ul>
<p>下面来分别实现它们</p>
<h3 id="限流实现"><a href="#限流实现" class="headerlink" title="限流实现"></a>限流实现</h3><blockquote>
<p>具体实现思路可见: <a target="_blank" rel="noopener" href="https://blog.rxliuli.com/p/1a8df23d/">JavaScript 防抖和节流</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数节流</span></span><br><span class="line"><span class="comment"> * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流</span></span><br><span class="line"><span class="comment"> * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作</span></span><br><span class="line"><span class="comment"> * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作</span></span><br><span class="line"><span class="comment"> * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值</span></span><br><span class="line"><span class="comment"> * 注: 返回函数结果的高阶函数需要使用 &#123;<span class="doctag">@link </span>Proxy&#125; 实现，以避免原函数原型链上的信息丢失</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>delay 最小间隔时间，单位为 ms</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>action 真正需要执行的操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Function&#125;</span> </span>包装后有节流功能的函数。该函数是异步的，与需要包装的函数 &#123;<span class="doctag">@link </span>action&#125; 是否异步没有太大关联</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">delay, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(action, &#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> curr = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (curr - last &gt; delay) &#123;</span><br><span class="line">          result = <span class="built_in">Reflect</span>.apply(target, thisArg, args);</span><br><span class="line">          last = curr;</span><br><span class="line">          resolve(result);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="自动超时"><a href="#自动超时" class="headerlink" title="自动超时"></a>自动超时</h3><blockquote>
<p>注: <code>asyncTimeout</code> 函数实际上只是为了避免一种情况，异步请求时间超过节流函数最小间隔时间导致结果返回顺序错乱。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为异步函数添加自动超时功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action 异步函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>包装后的异步函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncTimeout</span>(<span class="params">timeout, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(action, &#123;</span><br><span class="line">    <span class="function"><span class="title">apply</span>(<span class="params">_, _this, args</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.race([</span><br><span class="line">        <span class="built_in">Reflect</span>.apply(_, _this, args),</span><br><span class="line">        wait(timeout).then(<span class="built_in">Promise</span>.reject),</span><br><span class="line">      ]);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p><a target="_blank" rel="noopener" href="https://codepen.io/pen/?editors=1112">测试一下</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 模拟一个异步请求，接受参数并返回它，然后等待指定的时间</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> wait(ms);</span><br><span class="line">    <span class="keyword">return</span> ms;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = asyncTimeout(time, throttle(time, get));</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    fn(<span class="number">30</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">20</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">    fn(<span class="number">10</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      last = res;</span><br><span class="line">      sum += res;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="comment">// last 结果为 10，和 switchMap 的不同点在于会保留最小间隔期间的第一次，而抛弃掉后面的异步结果，和 switchMap 正好相反！</span></span><br><span class="line">  <span class="built_in">console</span>.log(last);</span><br><span class="line">  <span class="comment">// 实际上确实执行了 3 次，结果也确实为第一次次调用参数的 3 倍</span></span><br><span class="line">  <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>起初吾辈因为好奇实现了这种方式，但原以为会和 <code>concatMap</code> 类似的函数却变成了现在这样 – 更像倒置的 <code>switchMap</code> 了。不过由此看来这种方式的可行性并不大，毕竟，没人需要旧的数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实第一种实现方式属于 <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/rxjs">rxjs</a> 早就已经走过的道路，目前被 Angular 大量采用（类比于 React 中的 Redux）。但 rxjs 实在太强大也太复杂了，对于吾辈而言，仅仅需要一只香蕉，而不需要拿着香蕉的大猩猩，以及其所处的整个森林（此处原本是被人吐槽面向对象编程的隐含环境，这里吾辈稍微藉此吐槽一下动不动就上库的开发者）。</p>
<blockquote>
<p>可以看到吾辈在这里大量使用了 <code>Proxy</code>，那么，原因是什么呢？这个疑问就留到下次再说吧！</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/fa132fa479714abd999dc421ca971e1c/" data-id="ckmcqox5c00a90kuvafjohfca" data-title="JavaScript 异步时序问题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-05a42034e34e4636aace32cec81187f5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/05a42034e34e4636aace32cec81187f5/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/05a42034e34e4636aace32cec81187f5/">JavaScript 异步数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p>吾辈是一只在飞向太阳的萤火虫</p>
</blockquote>
<p>JavaScript 中的数组是一个相当泛用性的数据结构，能当数组，元组，队列，栈进行操作，更好的是 JavaScript 提供了很多原生的高阶函数，便于我们对数组整体操作。<br>然而，JavaScript 中的高阶函数仍有缺陷 – 异步！当你把它们放在一起使用时，就会感觉到这种问题的所在。</p>
<p>例如现在，有一组 id，我们要根据 id 获取到远端服务器 id 对应的值，然后将之打印出来。那么，我们要怎么做呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里只是为了模拟每个请求的时间可能是不定的</span></span><br><span class="line">  <span class="keyword">await</span> wait(<span class="built_in">Math</span>.random() * id * <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;内容: &quot;</span> + id.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ids = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>你或许会下意识地写出下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ids.forEach(<span class="keyword">async</span> (id) =&gt; <span class="built_in">console</span>.log(<span class="keyword">await</span> get(id)));</span><br></pre></td></tr></table></figure>
<p>事实上，控制台输出是无序的，而并非想象中的 1, 2, 3, 4 依次输出</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内容: 2 ​​​​​</span><br><span class="line">内容: 3 ​​​​​</span><br><span class="line">内容: 1 ​​​​​</span><br><span class="line">内容: 4</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？原因便是 JavaScript 中数组的高阶函数并不会等待异步函数的返回！当你在网络上搜索时，会发现很多人会说可以使用 <code>for-of</code>, <code>for-in</code> 解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">of</span> ids) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> get(id));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>或者，使用 <code>Promise.all</code> 也是一种解决方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  (<span class="keyword">await</span> <span class="built_in">Promise</span>.all(ids.map(get))).forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>然而，第一种方式相当于丢弃了 Array 的所有高阶函数，再次重返远古 <code>for</code> 循环时代了。第二种则一定会执行所有的异步函数，即便你需要使用的是 <code>find/findIndex/some/every</code> 这些高阶函数。那么，有没有更好的解决方案呢？</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>既然原生的 Array 不支持完善的异步操作，那么，为什么不由我们来实现一个呢？</p>
<p>实现思路:</p>
<ol>
<li> 创建异步数组类型 <code>AsyncArray</code></li>
<li> 内置一个数组保存当前异步操作数组的值</li>
<li> 实现数组的高阶函数并实现支持异步函数顺序执行</li>
<li> 获取到内置的数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">Array</span>.from(args);</span><br><span class="line">    <span class="built_in">this</span>._task = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> AsyncArray(...ids).forEach(<span class="keyword">async</span> (id) =&gt; <span class="built_in">console</span>.log(<span class="keyword">await</span> get(id)));</span><br></pre></td></tr></table></figure>
<p>打印结果确实有顺序了，看似一切很美好？</p>
<p>然而，当我们再实现一个 <code>map</code> 试一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">Array</span>.from(args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      res.push(<span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AsyncArray(...ids).map(get).forEach(<span class="keyword">async</span> (res) =&gt; <span class="built_in">console</span>.log(res));</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="comment">// (intermediate value).map(...).forEach is not a function</span></span><br></pre></td></tr></table></figure>
<p>然而会有问题，实际上 <code>map</code> 返回的是 <code>Promise</code>，所以我们还必须使用 <code>await</code> 进行等待</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  (<span class="keyword">await</span> <span class="keyword">new</span> AsyncArray(...ids).map(get)).forEach(<span class="keyword">async</span> (res) =&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>是不是感觉超级蠢？吾辈也是这样认为的！</p>
<h2 id="链式调用加延迟执行"><a href="#链式调用加延迟执行" class="headerlink" title="链式调用加延迟执行"></a>链式调用加延迟执行</h2><p>我们可以尝试使用链式调用加延迟执行修改这个 <code>AsyncArray</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存高阶函数传入的异步操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, args</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>异步操作的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>异步操作的参数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Function&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的操作类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Action.Type = &#123;</span><br><span class="line">  forEach: <span class="string">&quot;forEach&quot;</span>,</span><br><span class="line">  map: <span class="string">&quot;map&quot;</span>,</span><br><span class="line">  filter: <span class="string">&quot;filter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正实现的异步数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._arr = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      res.push(<span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._arr = res;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._arr = res;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">Array</span>.from(args);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>保存异步任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Action[]&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._task = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._task.push(<span class="keyword">new</span> Action(Action.Type.forEach, [fn]));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._task.push(<span class="keyword">new</span> Action(Action.Type.map, [fn]));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._task.push(<span class="keyword">new</span> Action(Action.Type.filter, [fn]));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 终结整个链式操作并返回结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      result = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AsyncArray(...ids)</span><br><span class="line">  .filter(<span class="keyword">async</span> (i) =&gt; i % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .map(get)</span><br><span class="line">  .forEach(<span class="keyword">async</span> (res) =&gt; <span class="built_in">console</span>.log(res))</span><br><span class="line">  .value();</span><br></pre></td></tr></table></figure>
<p>可以看到，确实符合预期了，然而每次都要调用 <code>value()</code>，终归有些麻烦。</p>
<h2 id="使用-then-以支持-await-自动结束"><a href="#使用-then-以支持-await-自动结束" class="headerlink" title="使用 then 以支持 await 自动结束"></a>使用 then 以支持 await 自动结束</h2><p>这里使用 <code>then()</code> 替代它以使得可以使用 <code>await</code> <strong>自动</strong>计算结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上面的其他内容...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 终结整个链式操作并返回结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params">resolve</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      result = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里使用 resolve(result) 是为了兼容 await 的调用方式</span></span><br><span class="line">    resolve(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，可以使用 <code>await</code> 结束这次链式调用了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> AsyncArray(...ids).map(get).forEach(<span class="keyword">async</span> (res) =&gt; <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>
<p>突然之间，我们发现了一个问题，为什么会这么慢？一个个去进行异步操作太慢了，难道就不能一次性全部发送出去，然后有序的处理结果就好了嘛？</p>
<h2 id="并发异步操作"><a href="#并发异步操作" class="headerlink" title="并发异步操作"></a>并发异步操作</h2><p>我们可以使用 <code>Promise.all</code> 并发执行异步操作，然后对它们的结果进行有序地处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发实现的异步数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAsyncArrayParallel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">_all</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(<span class="built_in">this</span>._arr.map(fn));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>._all(fn);</span><br><span class="line">    <span class="built_in">this</span>._arr = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="keyword">await</span> <span class="built_in">this</span>._all(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">await</span> <span class="built_in">this</span>._all(fn);</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">this</span>._arr.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>AsyncArray</code>，使用 <code>_AsyncArrayParallel</code> 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上面的其他内容...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 终结整个链式操作并返回结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params">resolve</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> InnerAsyncArrayParallel(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      result = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里使用 resolve(result) 是为了兼容 await 的调用方式</span></span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式不变。当然，由于使用 <code>Promise.all</code> 实现，也同样受到它的限制 – 异步操作实际上全部执行了。</p>
<h2 id="串行-并行相互转换"><a href="#串行-并行相互转换" class="headerlink" title="串行/并行相互转换"></a>串行/并行相互转换</h2><p>现在我们的 <code>_AsyncArray</code> 和 <code>_AsyncArrayParallel</code> 两个类只能二选一，所以，我们需要添加两个函数用于互相转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">Array</span>.from(args);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>保存异步任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;AsyncArrayAction[]&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._task = [];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否并行化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他内容...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">parallel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">serial</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._parallel</span><br><span class="line">      ? <span class="keyword">new</span> InnerAsyncArrayParallel(<span class="built_in">this</span>._arr)</span><br><span class="line">      : <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      result = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以在真正执行之前在任意位置对其进行转换了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> AsyncArray(...ids)</span><br><span class="line">  .parallel()</span><br><span class="line">  .filter(<span class="keyword">async</span> (i) =&gt; i % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">  .map(get)</span><br><span class="line">  .forEach(<span class="keyword">async</span> (res) =&gt; <span class="built_in">console</span>.log(res));</span><br></pre></td></tr></table></figure>
<h2 id="并发执行多个异步操作"><a href="#并发执行多个异步操作" class="headerlink" title="并发执行多个异步操作"></a>并发执行多个异步操作</h2><p>然而，上面的代码有一些隐藏的问题</p>
<ol>
<li><p><code>await</code> 之后返回值不是一个数组</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i * <span class="number">2</span>)); <span class="comment">// InnerAsyncArray &#123; _arr: [ 2, 4, 6, 8 ] &#125;</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>上面的 <code>map</code>, <code>filter</code> 调用在 <code>await</code> 之后仍会影响到下面的调用</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i * <span class="number">2</span>)); <span class="comment">// InnerAsyncArray &#123; _arr: [ 2, 4, 6, 8 ] &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// InnerAsyncArray &#123; _arr: [ 2, 4, 6, 8 ] &#125;</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li><p>并发调用的顺序不能确定，会影响到内部数组，导致结果不能确定</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids);</span><br><span class="line">  (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="keyword">await</span> asyncArray</span><br><span class="line">        .filter(<span class="keyword">async</span> (i) =&gt; i % <span class="number">2</span> === <span class="number">1</span>)</span><br><span class="line">        .map(<span class="keyword">async</span> (i) =&gt; i * <span class="number">2</span>)</span><br><span class="line">    ); <span class="comment">// InnerAsyncArray &#123; _arr: [ 2, 6 ] &#125;</span></span><br><span class="line">  &#125;)();</span><br><span class="line">  (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// InnerAsyncArray &#123; _arr: [ 2, 6 ] &#125;</span></span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>先解决第一个问题，这里只需要判断一下是否为终结操作（<code>forEach</code>），是的话就直接返回结果，否则继续下一次循环</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 其他内容...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._parallel</span><br><span class="line">      ? <span class="keyword">new</span> InnerAsyncArrayParallel(<span class="built_in">this</span>._arr)</span><br><span class="line">      : <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArray ||</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArrayParallel</span><br><span class="line">      ) &#123;</span><br><span class="line">        result = temp._arr;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经是终结操作就返回数组的值</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">          resolve(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，第一个问题简单解决</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i * <span class="number">2</span>)); <span class="comment">// [ 2, 4, 6, 8 ]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>第二、第三个问题看起来似乎是同一个问题？其实我们可以按照常规思维解决第一个问题。既然 <code>await</code> 之后仍然会影响到下面的调用，那就在 <code>then</code> 中把 <code>_task</code> 清空好了，修改 <code>then</code> 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 其他内容...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._parallel</span><br><span class="line">      ? <span class="keyword">new</span> InnerAsyncArrayParallel(<span class="built_in">this</span>._arr)</span><br><span class="line">      : <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArray ||</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArrayParallel</span><br><span class="line">      ) &#123;</span><br><span class="line">        result = temp._arr;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经是终结操作就返回数组的值</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">          resolve(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>._task = [];</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._task = [];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，第一个问题解决了，但第二个问题不会解决。究其原因，还是异步事件队列的问题，虽然 <code>async-await</code> 能够让我们以同步的方式写异步的代码，但千万不可忘记它们本质上还是<strong>异步</strong>的！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="keyword">await</span> asyncArray</span><br><span class="line">          .filter(<span class="keyword">async</span> (i) =&gt; i % <span class="number">2</span> === <span class="number">1</span>)</span><br><span class="line">          .map(<span class="keyword">async</span> (i) =&gt; i * <span class="number">2</span>)</span><br><span class="line">      ); <span class="comment">// [ 2, 6 ]</span></span><br><span class="line">    &#125;)(),</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 2, 6 ]</span></span><br><span class="line">    &#125;)(),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>可以看到，在使用 <code>await</code> 进行等待之后就如同预期的 <code>_task</code> 被清空了。然而，并发执行的没有等待的 <code>await asyncArray</code> 却有奇怪的问题，因为它是在 <code>_task</code> 清空之前执行的。</p>
<p>并且，这带来一个副作用: 无法缓存操作了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids).map(<span class="function">(<span class="params">i</span>) =&gt;</span> i * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 2, 4, 6, 8 ]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="使用不可变数据"><a href="#使用不可变数据" class="headerlink" title="使用不可变数据"></a>使用不可变数据</h2><p>为了解决直接修改内部数组造成的问题，我们可以使用不可变数据解决这个问题。试想：如果我们每次操作都返回一个新的 <code>AsyncArray</code>，他们之间没有关联，这样又如何呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">Array</span>.from(args);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>保存异步任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Action[]&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._task = [];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否并行化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._addTask(Action.Type.forEach, [fn]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._addTask(Action.Type.map, [fn]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._addTask(Action.Type.filter, [fn]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">parallel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">serial</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_addTask</span>(<span class="params">type, args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> AsyncArray(...this._arr);</span><br><span class="line">    result._task = [...this._task, <span class="keyword">new</span> Action(type, args)];</span><br><span class="line">    result._parallel = <span class="built_in">this</span>._parallel;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 终结整个链式操作并返回结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._parallel</span><br><span class="line">      ? <span class="keyword">new</span> InnerAsyncArrayParallel(<span class="built_in">this</span>._arr)</span><br><span class="line">      : <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArray ||</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArrayParallel</span><br><span class="line">      ) &#123;</span><br><span class="line">        result = temp._arr;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经是终结操作就返回数组的值</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">          resolve(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次测试上面的那第三个问题，发现已经一切正常了呢</p>
<ul>
<li>并发调用的顺序不能确定，但不会影响内部数组了，结果是确定的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="keyword">await</span> asyncArray</span><br><span class="line">          .filter(<span class="keyword">async</span> (i) =&gt; i % <span class="number">2</span> === <span class="number">1</span>)</span><br><span class="line">          .map(<span class="keyword">async</span> (i) =&gt; i * <span class="number">2</span>)</span><br><span class="line">      ); <span class="comment">// [ 2, 6 ]</span></span><br><span class="line">    &#125;)(),</span><br><span class="line">    (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line">    &#125;)(),</span><br><span class="line">  ]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<ul>
<li>操作可以被缓存</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> asyncArray = <span class="keyword">new</span> AsyncArray(...ids).map(<span class="function">(<span class="params">i</span>) =&gt;</span> i * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 2, 4, 6, 8 ]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> asyncArray); <span class="comment">// [ 2, 4, 6, 8 ]</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>下面吾辈把完整的代码贴出来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存高阶函数传入的异步操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, args</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>异步操作的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>异步操作的参数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Function&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的操作类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Action.Type = &#123;</span><br><span class="line">  forEach: <span class="string">&quot;forEach&quot;</span>,</span><br><span class="line">  map: <span class="string">&quot;map&quot;</span>,</span><br><span class="line">  filter: <span class="string">&quot;filter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正实现的异步数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._arr = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      res.push(<span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._arr = res;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> fn(arr[i], i, <span class="built_in">this</span>)) &#123;</span><br><span class="line">        res.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._arr = res;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAsyncArrayParallel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arr</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">_all</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(<span class="built_in">this</span>._arr.map(fn));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>._all(fn);</span><br><span class="line">    <span class="built_in">this</span>._arr = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="keyword">await</span> <span class="built_in">this</span>._all(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">await</span> <span class="built_in">this</span>._all(fn);</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">this</span>._arr.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncArray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._arr = <span class="built_in">Array</span>.from(args);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@field </span>保存异步任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Action[]&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._task = [];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否并行化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">forEach</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._addTask(Action.Type.forEach, [fn]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._addTask(Action.Type.map, [fn]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">filter</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._addTask(Action.Type.filter, [fn]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">parallel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">serial</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._parallel = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_addTask</span>(<span class="params">type, args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> AsyncArray(...this._arr);</span><br><span class="line">    result._task = [...this._task, <span class="keyword">new</span> Action(type, args)];</span><br><span class="line">    result._parallel = <span class="built_in">this</span>._parallel;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 终结整个链式操作并返回结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">this</span>._parallel</span><br><span class="line">      ? <span class="keyword">new</span> InnerAsyncArrayParallel(<span class="built_in">this</span>._arr)</span><br><span class="line">      : <span class="keyword">new</span> InnerAsyncArray(<span class="built_in">this</span>._arr);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">this</span>._arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> task <span class="keyword">of</span> <span class="built_in">this</span>._task) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = <span class="keyword">await</span> arr[task.type](...task.args);</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArray ||</span><br><span class="line">        temp <span class="keyword">instanceof</span> InnerAsyncArrayParallel</span><br><span class="line">      ) &#123;</span><br><span class="line">        result = temp._arr;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经是终结操作就返回数组的值</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">          resolve(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，关于 JavaScript 中如何封装一个可以使用异步操作高阶函数的数组就先到这里了，完整的 JavaScript 异步数组请参考吾辈的 <a target="_blank" rel="noopener" href="https://github.com/rxliuli/rx-util/blob/master/src/module/array/AsyncArray.ts">AsyncArray</a>（使用 TypeScript 编写）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/05a42034e34e4636aace32cec81187f5/" data-id="ckmcqox5i00bj0kuv49v13xdr" data-title="JavaScript 异步数组" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/19/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/" rel="tag">electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/" rel="tag">grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jetbrains/" rel="tag">jetbrains</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webstorm/" rel="tag">webstorm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AC%E5%8F%B8/" rel="tag">公司</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A3%E5%91%8A/" rel="tag">宣告</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90/" rel="tag">开源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" rel="tag">待更新</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C/" rel="tag">经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 12.14px;">css</a> <a href="/tags/electron/" style="font-size: 15.71px;">electron</a> <a href="/tags/git/" style="font-size: 12.86px;">git</a> <a href="/tags/grid/" style="font-size: 10.71px;">grid</a> <a href="/tags/java/" style="font-size: 19.29px;">java</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jetbrains/" style="font-size: 12.14px;">jetbrains</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/markdown/" style="font-size: 10.71px;">markdown</a> <a href="/tags/react/" style="font-size: 14.29px;">react</a> <a href="/tags/sql/" style="font-size: 14.29px;">sql</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vscode/" style="font-size: 12.86px;">vscode</a> <a href="/tags/vue/" style="font-size: 16.43px;">vue</a> <a href="/tags/webstorm/" style="font-size: 10px;">webstorm</a> <a href="/tags/windows/" style="font-size: 17.14px;">windows</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 12.86px;">个人</a> <a href="/tags/%E5%85%AC%E5%8F%B8/" style="font-size: 10px;">公司</a> <a href="/tags/%E5%91%A8%E6%8A%A5/" style="font-size: 10px;">周报</a> <a href="/tags/%E5%AE%A3%E5%91%8A/" style="font-size: 10px;">宣告</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.57px;">工具</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 17.86px;">工程化</a> <a href="/tags/%E5%BC%80%E6%BA%90/" style="font-size: 10px;">开源</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" style="font-size: 15px;">异步</a> <a href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" style="font-size: 10.71px;">待更新</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 18.57px;">杂谈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 11.43px;">经验</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 12.14px;">读书</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 11.43px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/14/8fb2d58463ae4191ac064a76e15bffbd/">2021 第十周</a>
          </li>
        
          <li>
            <a href="/2021/03/12/7e7131c07c984d928ba3fefa7a9cef06/">读书-[颓废与沉默：透视犬儒文化]</a>
          </li>
        
          <li>
            <a href="/2021/03/02/db74e6e5d2444bc3b6e185a7b338bbf6/">electron 开发经验之谈系列-在渲染、主进程间共享数据</a>
          </li>
        
          <li>
            <a href="/2021/02/27/06cb464179cf45c598208534705aae3c/">2020 吾辈在公司推动的前端技术演进</a>
          </li>
        
          <li>
            <a href="/2021/02/23/cd66150d2b86448590fcc9bb2419c0b2/">实践 lerna monorepo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>