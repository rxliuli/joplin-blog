<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-a699763f23e84702b8a742f5ddce82d7" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/a699763f23e84702b8a742f5ddce82d7/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/a699763f23e84702b8a742f5ddce82d7/">JavaScript =&gt; TypeScript 迁移体验</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>如果你使用 JavaScript 没出现什么问题，那吾辈就不推荐你迁移到 TypeScript！</p>
</blockquote>
<ul>
<li><code>JavaScript</code> 不能无缝迁移到 <code>TypeScript</code>！</li>
<li><code>JavaScript</code> 不能无缝迁移到 <code>TypeScript</code>！</li>
<li><code>JavaScript</code> 不能无缝迁移到 <code>TypeScript</code>！</li>
</ul>
<p>重要的话说三遍，TypeScript 是 JavaScript 的超集，所以有很多人认为（并宣称）JavaScript 可以很容易迁移到 TypeScript，甚至是无缝迁移的！<br>导致了 JavaScript 开发者满心欢喜的入坑了 TypeScript（包括吾辈），然后掉进了坑里，甚至差点爬不出来。。。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>问: 为什么吾辈用 JavaScript 用的好好的，偏偏自找麻烦去入坑了 TypeScript 了呢？</li>
<li>答: JavaScript 因为一些固有问题和主流编辑器 VSCode 支持不力，导致代码写起来会感觉很不方便</li>
<li>问: 具体谈谈</li>
<li>答: 有很多令人不满意的地方，这里只谈几点:<ul>
<li>JavaScript 没有类型，所以写 JSDoc 感觉很麻烦，但不写又不太好。然而，JavaScript 代码写的太顺利的话就可能忘记加上 JSDoc，之后代码就很难维护。</li>
<li>VSCode 支持不好，这点或许才是最重要的: VSCode 使用 TypeScript 编写，并基于 TypeScript 实现的语法提示功能，虽然也支持根据 JSDoc 的注释进行提示，然而当你去做一个开源项目，并将之发布到 npm 之后，情况发生了变化。。。当一个用户使用 npm/yarn 安装了你的项目之后，发现并没有任何代码提示，如此你会怎么做？</li>
<li>复杂的类型很难使用 JSDoc 表达出来并清晰地告诉调用者，例如高阶函数。</li>
<li>等等。。。。</li>
</ul>
</li>
</ul>
<p>是的，TypeScript 确实解决了以上的一些问题，却同时带入了另外一些问题。</p>
<ul>
<li>TypeScript 有类型了，然而即便有类型推导，还是要加很多类型，而且有时候 TypeScript 和我们的想法不同的时候还要用 <code>!</code>/<code>(t as unkonwn) as R</code> 这种 <strong>hack 技巧</strong>。</li>
<li>VSCode 天生支持 TypeScript，但 TypeScript 的 API Doc 生成工具实在谈不上多好，例如 <a target="_blank" rel="noopener" href="https://typedoc.org/">typedoc</a> 相比于 <a target="_blank" rel="noopener" href="https://esdoc.org/">ESDoc</a> 不过是个半吊子。。。</li>
<li>事实上，即便使用 TypeScript 写的项目，只要使用者没有在 <code>jsconfig.json</code> 中进行配置的话，提示仍然默认不存在</li>
<li>TypeScript 的类型系统是把双刃剑，实在太复杂了，当然有理由认为是为了兼容 JavaScript。然而在 TypeScript 想要正确的表达类型也是一件相当困难的事情。</li>
</ul>
<h2 id="类型系统踩坑"><a href="#类型系统踩坑" class="headerlink" title="类型系统踩坑"></a>类型系统踩坑</h2><h3 id="如何声明参数与返回值类型相同？"><a href="#如何声明参数与返回值类型相同？" class="headerlink" title="如何声明参数与返回值类型相同？"></a>如何声明参数与返回值类型相同？</h3><p>例如一个函数接受一个参数，并返回一个完全相同类型的返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnItself</span>(<span class="params">obj: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假使这样写的话，类型系统就不会发挥作用了，调用函数的结果将是 <code>any</code>，意味着类型系统将没有效果。</p>
<p>例如下面的代码会被 ts 认为是错误</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码并不会有提示</span></span><br><span class="line"><span class="built_in">console</span>.log(returnItself(<span class="string">&quot;abc&quot;</span>).length);</span><br></pre></td></tr></table></figure>
<p>需要写成</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnItself</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params">obj: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要声明了参数和返回值是同一类型，默认为 any，但具体取决于参数的不同而使得返回值也不同，返回值不会丢失类型信息。</p>
<h3 id="如何声明参数与返回值类型有关联？"><a href="#如何声明参数与返回值类型有关联？" class="headerlink" title="如何声明参数与返回值类型有关联？"></a>如何声明参数与返回值类型有关联？</h3><p>例如一个计算函数执行时间的函数 <code>timing</code>，接受一个函数参数，有可能是同步/异步的，所以要根据函数的返回值确定 <code>timing</code> 的返回值为 <code>number/Promise&lt;number&gt;</code></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> | <span class="title">Promise</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begin = performance.now();</span><br><span class="line">  <span class="keyword">const</span> result = fn();</span><br><span class="line">  <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> performance.now() - begin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.then(<span class="function">() =&gt;</span> performance.now() - begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而在使用时你会发现返回值类型不太对，因为 <code>timing</code> 的返回值是 <code>number | Promise&lt;number&gt;</code> 这种复合类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会提示类型错误</span></span><br><span class="line"><span class="keyword">const</span> res: <span class="built_in">number</span> = timing(<span class="function">() =&gt;</span> sleep(<span class="number">100</span>));</span><br><span class="line">expect(res).toBeGreaterThan(<span class="number">99</span>);</span><br></pre></td></tr></table></figure>
<p>解决方案有二</p>
<ol>
<li> 使用函数声明重载</li>
<li> 使用类型判断</li>
</ol>
<h4 id="使用函数声明重载"><a href="#使用函数声明重载" class="headerlink" title="使用函数声明重载"></a>使用函数声明重载</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params">fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span>): <span class="title">Promise</span>&lt;<span class="title">number</span>&gt;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params">fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> | <span class="title">Promise</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begin = performance.now();</span><br><span class="line">  <span class="keyword">const</span> result = fn();</span><br><span class="line">  <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> performance.now() - begin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.then(<span class="function">() =&gt;</span> performance.now() - begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉函数声明顺序有点奇怪是因为 <code>Promise&lt;any&gt;</code> 属于 <code>any</code> 的子类，而函数声明重载必须由具体到宽泛。当然，我们有方法可以在 <code>any</code> 中排除掉 <code>Promise&lt;any&gt;</code>，这样顺序就对了！</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; Exclude&lt;<span class="built_in">any</span>, <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params">fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span>): <span class="title">Promise</span>&lt;<span class="title">number</span>&gt;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> | <span class="title">Promise</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begin = performance.now();</span><br><span class="line">  <span class="keyword">const</span> result = fn();</span><br><span class="line">  <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> performance.now() - begin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.then(<span class="function">() =&gt;</span> performance.now() - begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用类型判断"><a href="#使用类型判断" class="headerlink" title="使用类型判断"></a>使用类型判断</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> | <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 函数返回类型是 Promise 的话，则返回 Promise&lt;number&gt;，否则返回 number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">R</span> <span class="title">extends</span> <span class="title">Promise</span>&lt;<span class="title">any</span>&gt; ? <span class="title">Promise</span>&lt;<span class="title">number</span>&gt; : <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begin = performance.now();</span><br><span class="line">  <span class="keyword">const</span> result = fn();</span><br><span class="line">  <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> (performance.now() - begin) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.then(<span class="function">() =&gt;</span> performance.now() - begin) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>可以看出来，第一种方式的优点在于可以很精细的控制每个不同参数对应的返回值，并且，可以处理特别复杂的情况，缺点则是如果写 doc 文档的话需要为每个声明都写上，即便，它们有大部分注释是相同的。<br>而第二种方式，则在代码量上有所减少，而且不必使用函数声明重载。缺点则是无法应对特别复杂的情况，另外一点就是使用了 <code>any</code>，可能会造成<strong>重构火葬场</strong>。</p>
<h3 id="TypeScript-类型系统就是认为吾辈错了怎么办？"><a href="#TypeScript-类型系统就是认为吾辈错了怎么办？" class="headerlink" title="TypeScript 类型系统就是认为吾辈错了怎么办？"></a>TypeScript 类型系统就是认为吾辈错了怎么办？</h3><p>有时候，明明自己知道是正确的，但 TypeScript 偏偏认为你写错了。思考以下功能如何实现？</p>
<p>将 Array 转换为 Map，接受三个参数</p>
<ol>
<li> 需要转换的数组</li>
<li> 将数组元素转换为 Map key 的函数</li>
<li> 将数组元素转换为 Map value 的函数，可选，默认为数组元素</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnItself</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params">obj: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayCallback&lt;T, R&gt; = <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span>, arr: T[]</span>) =&gt;</span> R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">arrayToMap</span>&lt;<span class="title">T</span>, <span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  arr: T[],</span></span></span><br><span class="line"><span class="function"><span class="params">  kFn: ArrayCallback&lt;T, K&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  vFn: ArrayCallback&lt;T, V&gt; = returnItself</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    (res, item, index, arr) =&gt;</span><br><span class="line">      res.set(kFn(item, index, arr), vFn(item, index, arr)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Map</span>&lt;K, V&gt;()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能有以上代码，然而实际上 <code>returnItself</code> 无法直接赋值给 <code>ArrayCallback&lt;T, V&gt;</code>。当然，我们知道，这一定是可以赋值的，但 TypeScript 却无法编译通过！</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">arrayToMap</span>&lt;<span class="title">T</span>, <span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  arr: T[],</span></span></span><br><span class="line"><span class="function"><span class="params">  kFn: ArrayCallback&lt;T, K&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 是的，这里添加 as any 就好了</span></span></span></span><br><span class="line"><span class="function"><span class="params">  vFn: ArrayCallback&lt;T, V&gt; = returnItself <span class="keyword">as</span> <span class="built_in">any</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    (res, item, index, arr) =&gt;</span><br><span class="line">      res.set(kFn(item, index, arr), vFn(item, index, arr)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Map</span>&lt;K, V&gt;()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果 <code>returnItself</code> 用的比较多的话（例如吾辈），可以使用另一种方式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 returnItself 的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnItself</span>&lt;<span class="title">T</span>, <span class="title">R</span> = <span class="title">T</span>&gt;(<span class="params">obj: T</span>): <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ArrayCallback&lt;T, R&gt; = <span class="function">(<span class="params">item: T, index: <span class="built_in">number</span>, arr: T[]</span>) =&gt;</span> R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">arrayToMap</span>&lt;<span class="title">T</span>, <span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  arr: T[],</span></span></span><br><span class="line"><span class="function"><span class="params">  kFn: ArrayCallback&lt;T, K&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  vFn: ArrayCallback&lt;T, V&gt; = returnItself</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(</span><br><span class="line">    (res, item, index, arr) =&gt;</span><br><span class="line">      res.set(kFn(item, index, arr), vFn(item, index, arr)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Map</span>&lt;K, V&gt;()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何强制调用非空时对象上的函数？"><a href="#如何强制调用非空时对象上的函数？" class="headerlink" title="如何强制调用非空时对象上的函数？"></a>如何强制调用非空时对象上的函数？</h3><p>当有时候你得到一个对象可能为空时，无法直接调用其上的函数，会提示函数不存在。<br>例如下面从数组中查询字符串，然后获取长度，在 TypeScript 中便会报错，因为 str 的类型为 string/undefined。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.find(<span class="function">(<span class="params">s</span>) =&gt;</span> s === <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br></pre></td></tr></table></figure>
<p>之前使用 JavaScript 从未遇到过这种事情，事实上确实有可能为空，但 JavaScript 太过于动态，并不会提示错误，而 TypeScript 就会提示这种低级错误，因为类型系统。<br>但是啊，凡事都有例外，当吾辈确实想调用 string 上的函数时报错真的是有点讨厌，那么有什么办法呢？</p>
<ol>
<li><p>使用 <code>!</code> 强制调用</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.find(<span class="function">(<span class="params">s</span>) =&gt;</span> s === <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str!.length);</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>(str as any)</code> 转换为 any 类型之后再随意调用任何函数</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.find(<span class="function">(<span class="params">s</span>) =&gt;</span> s === <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log((str <span class="keyword">as</span> <span class="built_in">any</span>).length);</span><br></pre></td></tr></table></figure></li>
<li><p>使用注释 <code>// @ts-ignore</code> 忽略错误（非常强力，少用）</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.find(<span class="function">(<span class="params">s</span>) =&gt;</span> s === <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br></pre></td></tr></table></figure>
<p>注意: 三种方式推荐程度逐渐降低，因为后两种实际上都会忽略类型系统，导致编写代码没有提示！</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截至目前为止，吾辈已经着手使用 TypeScript 重构工具函数库 <a target="_blank" rel="noopener" href="https://github.com/rxliuli/rx-util">rx-util</a> 两周了，基本上打包配置，文档生成，类型定义基本上算是大致完成，感觉之后的公共项目大概都会用 TypeScript 实现了，毕竟前端主流开发工具 VSCode 对其的支持真的很好，而且 TypeScript 的接口这种概念真的太有用了！</p>
<h2 id="一些吐槽"><a href="#一些吐槽" class="headerlink" title="一些吐槽"></a>一些吐槽</h2><p>使用了有一段时间了，这里不得不再次声明一下，TypeScript 的类型系统复杂度超乎想象，如果你没有准备好在生产系统中使用，那就最好不要使用。缺少关于类型系统（尤其是原生类型，例如 <code>PromiseLike</code> 居然没有人讲过）的说明，使得 TypeScript 的类型系统很多时候看起来都只是为了<strong>好玩</strong>而已。而且稍微复杂一点的情况思考如何设计类型的时间将会超过具体的代码实现，使用它请务必再三慎重考虑！</p>
<p>TypeScript 的类型系统为了兼容 JavaScript 缺陷实在太大了。</p>
<blockquote>
<p>参见某个知乎用户的话:</p>
</blockquote>
<ol>
<li><p>ts 写不出一个合并对象的方法</p>
<p> 下面是一个 js 合并对象的方法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">dest, ...sources</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(dest, ...sources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这么一个简单的方法，ts 写不出不丢失类型信息的实现。</p>
<p> 下面贴的是 typescript 源码中对 Object.assign 的声明，我相信都能看出有多傻：</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign&lt;T, U&gt;(target: T, <span class="attr">source</span>: U): T &amp; U;</span><br><span class="line">assign&lt;T, U, V&gt;(target: T, <span class="attr">source1</span>: U, <span class="attr">source2</span>: V): T &amp; U &amp; V;</span><br><span class="line">assign&lt;T, U, V, W&gt;(target: T, <span class="attr">source1</span>: U, <span class="attr">source2</span>: V, <span class="attr">source3</span>: W): T &amp; U &amp; &amp; W;</span><br><span class="line">assign(target: <span class="built_in">object</span>, ...sources: <span class="built_in">any</span>[]): <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>
<p> 按这个实现，多于 4 个参数就直接丢掉类型信息了，建议 ts 至少把 A-Z 都作为泛型量用上…</p>
</li>
<li><p>一些很明显的类型推断却推断不出来</p>
<p> 用 assert 方法做参数检查是很常用的做法，一个简单的 assert 方法：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">condition, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后看这样一段代码：</p>
 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  assert(<span class="keyword">typeof</span> p === <span class="string">&quot;number&quot;</span>, <span class="string">&quot;p is a number&quot;</span>);</span><br><span class="line">  p.length; <span class="comment">// 这里报错，ts 竟然不知道到这一步 p 必定是 string 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/a699763f23e84702b8a742f5ddce82d7/" data-id="ckmcqox4b006z0kuvaxv1c2oj" data-title="JavaScript =&gt; TypeScript 迁移体验" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-a7418dcc845e45c4b342cff1d6fefc61" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/a7418dcc845e45c4b342cff1d6fefc61/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/a7418dcc845e45c4b342cff1d6fefc61/">Android 常用 App 清单</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>该清单只是吾辈所用，使用工具因人而异，若是你对清单中的内容有何异议，可以在下方进行留言，吾辈会尽快阅读并回复！</p>
<blockquote>
<p>附：列出的 Google Drive 链接是因为某些第三方 App 不在 Play Store 之中，而且在可预期的很长时间内都不可能在（Youtube 第三方客户端）</p>
</blockquote>
<h2 id="Google-全家桶"><a href="#Google-全家桶" class="headerlink" title="Google 全家桶"></a>Google 全家桶</h2><p>这里首先说明使用 Google 全家桶的原因：虽然 Google 最近声名狼藉，然而相比于 _国内肆无忌惮的获取数据，甚至百度明目张胆地说出“中国人就是喜欢拿隐私换方便”_，Google 还是显得像一朵 <strong>白百合</strong>。而且 Google 也确实不会明目张胆的找人要隐私，它只会偷偷摸摸的去做（#笑哭）。而多个的 App 都使用同一家公司的优势是巨大的：<strong>一切数据皆在云端，后台服务体贴之至</strong>。更何况 Google 的服务大多数都是全端跨平台的，对于同时使用 PC/Mobile 的使用者而言优势巨大。</p>
<h3 id="Play-Store：应用商店"><a href="#Play-Store：应用商店" class="headerlink" title="Play Store：应用商店"></a>Play Store：应用商店</h3><p>Google 家的应用商店，主要可以强制替代国内系统自带的应用商店（<strong>垃圾商店，遍地广告</strong>），而且国内应用相对于国内版本要干净一些（例如 QQ/WeChat）。</p>
<h3 id="GMail：Google-家的电子邮件"><a href="#GMail：Google-家的电子邮件" class="headerlink" title="GMail：Google 家的电子邮件"></a>GMail：Google 家的电子邮件</h3><p>跨平台的电子邮件。如果需要经常使用电子邮件（订阅内容/公司同事交流/GreasyFork 反馈/GitHub Issue/各种网络服务），那么 Gmail 是当之无愧的首选。在 Web 版本上在所有电子邮件中都是首屈一指的，在 Android 上的表现也是相当不错，毕竟是在自家的系统上。</p>
<h3 id="Google-通讯录：Google-家的通讯录"><a href="#Google-通讯录：Google-家的通讯录" class="headerlink" title="Google 通讯录：Google 家的通讯录"></a>Google 通讯录：Google 家的通讯录</h3><p>跨平台的联系人功能。不仅仅是电话号码，甚至于 <strong>Email/IM/网站</strong> 都能作为一个 <strong>联系人</strong>。更有趣的是在 Android 上通过联系人打电话，在 Web 上却可以通过邮件（Gmail）进行联系了呢！</p>
<blockquote>
<p>注：Gmail 内置集成了通讯录。</p>
</blockquote>
<h3 id="Google-翻译：目前最好的翻译"><a href="#Google-翻译：目前最好的翻译" class="headerlink" title="Google 翻译：目前最好的翻译"></a>Google 翻译：目前最好的翻译</h3><p>跨平台的多语言翻译。目前应该是最好的翻译了，Google Chrome 自带的翻译可是为 Google 积累了巨大的原始数据，对于翻译质量的提升也是理所当然的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Surfboard：上网必须"><a href="#Surfboard：上网必须" class="headerlink" title="Surfboard：上网必须"></a>Surfboard：上网必须</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://play.google.com/store/apps/details?id=com.getsurfboard">官方</a></p>
</blockquote>
<p>为了正常浏览网络折腾与支付一些代价都是微不足道的，比 <code>SS/SSR</code> UI/UX 好点，很多地方都支持搜索就很赞。</p>
<blockquote>
<p>附：最近网络盛传 V2Ray 更好，然而对于吾辈（使用者）而言，却是并未看到特别明显的优势，所以暂未切换过去。。。</p>
</blockquote>
<h3 id="Twitter：国外的网络社区"><a href="#Twitter：国外的网络社区" class="headerlink" title="Twitter：国外的网络社区"></a>Twitter：国外的网络社区</h3><p>对于吾辈而言，中文推圈的乐趣逐渐减少，现今早已不比曾经了。之前的那么多有趣的人和事，如今却都已消逝，<strong>Eric/Neko/泉</strong>。。。太多人在乎的人离去了，水军也进入了这个小小的圈子，Twitter 在吾辈的心中也渐渐和 QQ 一个等级了</p>
<h3 id="Telegram：安全私密的-IM"><a href="#Telegram：安全私密的-IM" class="headerlink" title="Telegram：安全私密的 IM"></a>Telegram：安全私密的 IM</h3><p>相比于 Twitter 是个社区，Telegram 则专注于用户之间的交流。开源（客户端）免费可端对端加密通讯，使得它受到许多推油的喜爱。Telegram 最新版的官方客户端已经做得足够好了，<code>Plus/TelegramX</code> 什么的基本上也不需要了呢</p>
<h3 id="QQ：国内广泛使用的-IM"><a href="#QQ：国内广泛使用的-IM" class="headerlink" title="QQ：国内广泛使用的 IM"></a>QQ：国内广泛使用的 IM</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://drive.google.com/open?id=1bSd3jtUgqo_o7Nl_E5xl__0QnmdKg4FA">第三方</a></p>
</blockquote>
<p>国内广泛使用的 IM，曾经的同学什么的都在这里了（虽然吾辈曾经为了转型 Twitter 而清空过 QQ 就是了 #中二病）。这里吾辈使用了第三方修改版，主要是为了去除 QQ 的广告以及功能增强。</p>
<ul>
<li>去除无用的侧边栏</li>
<li>界面上稍微皮了一下</li>
<li>破解撤回</li>
<li>破解闪照</li>
<li>破解口令红包</li>
</ul>
<h3 id="WeChat：国内不得不用联系工具"><a href="#WeChat：国内不得不用联系工具" class="headerlink" title="WeChat：国内不得不用联系工具"></a>WeChat：国内不得不用联系工具</h3><p>国内不得不用的 IM，名为微信，实为<strong>巨信</strong>。不仅安装包极其巨大，而且连基本的数据同步，都没有做好－－以安全之名。然而 WeChat 究竟有没有保留原始数据，又有没有把数据交给政府审查，相信大家心里自然明白。</p>
<blockquote>
<p>已加入冰箱，彻底不允许后台运行。</p>
</blockquote>
<h3 id="Kiwi：Android-上扩展性最好的类-Chrome-浏览器"><a href="#Kiwi：Android-上扩展性最好的类-Chrome-浏览器" class="headerlink" title="Kiwi：Android 上扩展性最好的类 Chrome 浏览器"></a>Kiwi：Android 上扩展性最好的类 Chrome 浏览器</h3><p>在 PC 上，Google Chrome 是当之无愧的 <code>Number One</code>。然而，在 Android 上，Chrome for Android 并不支持插件。虽然 Google 宣称定位是 <strong>简洁高效的浏览体验</strong>，然而是不是为了推广使用 App 却并未可知，所以在 Android 上能使用附加组件（插件）的类 Chrome 浏览器 Kiwi 就是扩展性最好的浏览器（类似的还有 Firefox，但速度真的太慢了）。</p>
<p>常用 Plugin 列表</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/">uBlock Origin</a>：广告过滤插件</li>
<li><a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/darkreader/">Dark Reader</a>：全局黑色主题</li>
<li><a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/tampermonkey/">Tampermonkey</a>：UserJS 脚本</li>
<li><a target="_blank" rel="noopener" href="https://addons.mozilla.org/en-US/firefox/addon/%E7%BD%91%E9%A1%B5%E7%BF%BB%E8%AF%91-bing-microsoft-translator/">必应网页翻译</a>：全文翻译</li>
</ul>
<p>常用 UserJS 列表</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://greasyfork.org/zh-CN/scripts/375653">Mobile 上知乎自动展开答案</a>：在 Mobile 上自动展开知乎问题的答案</li>
<li><a target="_blank" rel="noopener" href="https://greasyfork.org/zh-CN/scripts/342">Text To link</a>：网页上的文字转换为链接</li>
<li><a target="_blank" rel="noopener" href="https://greasyfork.org/zh-CN/scripts/29762">网盘自动填写密码</a>：百度网盘自动填入提取码</li>
<li><a target="_blank" rel="noopener" href="https://greasyfork.org/zh-CN/scripts/14146">网页限制解除</a>：解除网页的复制粘贴限制</li>
</ul>
<h3 id="条码扫描器：开源的条码扫描器"><a href="#条码扫描器：开源的条码扫描器" class="headerlink" title="条码扫描器：开源的条码扫描器"></a>条码扫描器：开源的条码扫描器</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/zxing/zxing">GitHub</a></p>
</blockquote>
<p>开源的条码扫描器，比 WeChat 扫描安全一些，而且便于第三方集成（Firefox 搜索框）。</p>
<h3 id="Nova-启动器：Nova-桌面"><a href="#Nova-启动器：Nova-桌面" class="headerlink" title="Nova 启动器：Nova 桌面"></a>Nova 启动器：Nova 桌面</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://drive.google.com/open?id=1EMcoMet27dN-ptsAG7yypTUqOO_Ip2pC">Pro 破解版</a></p>
</blockquote>
<p>还不错的第三方桌面，在很早之前就已经出现了。有一些自定义手势相当方便，长按 Home 搜索应用，双击屏幕锁屏。并支持第三方图标库，例如下面的 Pixel Icon Pack。</p>
<h3 id="Pixel-Icon-Pack：全而大-App-图标库"><a href="#Pixel-Icon-Pack：全而大-App-图标库" class="headerlink" title="Pixel Icon Pack：全而大 App 图标库"></a>Pixel Icon Pack：全而大 App 图标库</h3><p>虽然吾辈最喜欢的是 material 风格，然而 material 主题的图标数量实在不够。而 Pixel 这款图标库的数量足够庞大，包含了 6910+ 个图标，覆盖了绝大多数的 App，统一了桌面 App 的图标。</p>
<h3 id="FastHub：GitHub-第三方客户端"><a href="#FastHub：GitHub-第三方客户端" class="headerlink" title="FastHub：GitHub 第三方客户端"></a>FastHub：GitHub 第三方客户端</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/k0shk0sh/FastHub">GitHub</a></p>
</blockquote>
<p>2020-07-14 更新</p>
<p>FastHub 才是最好的，虽然已经有官方客户端了，但功能上还比不上 FastHub。</p>
<hr>
<p>虽然 GitHub 是全世界最大的同性社交网站（代码托管平台），然而并没有官方的 Mobile 客户端。OpenHub 正是 GitHub 的一个第三方客户端，可以方便的在 Mobile 上使用 GitHub。</p>
<h3 id="淘宝-Lite：淘宝海外版"><a href="#淘宝-Lite：淘宝海外版" class="headerlink" title="淘宝 Lite：淘宝海外版"></a>淘宝 Lite：淘宝海外版</h3><p>你是否也曾厌恶淘宝的臃肿，是否讨厌淘宝的强制升级？现在，我们有了新的选择：淘宝 Lite，名副其实的精简版。主要面向国外用户，我们在地区中选择 <strong>全球</strong> 即可正常使用淘宝进行购物啦<br>主要优点</p>
<ul>
<li>没有各种广告</li>
<li>没有各种看似强大然并卵的功能</li>
<li>不强制升级</li>
<li>没有强制索取权限</li>
<li>包含完整的购物体验</li>
</ul>
<h3 id="支付宝：国内通用移动支付"><a href="#支付宝：国内通用移动支付" class="headerlink" title="支付宝：国内通用移动支付"></a>支付宝：国内通用移动支付</h3><p>国内广泛使用的移动支付工具，在一线城市（广州）基本上带个 Mobile 就能到处走了。相比于 WeChat，支付宝给吾辈的感觉更好。。。WeChat 总让吾辈觉得是只想在国内发展的一个毒瘤 App，而支付宝是有志于开拓世界的（无论影响好坏）。</p>
<h3 id="LastPass：全端密码管理器"><a href="#LastPass：全端密码管理器" class="headerlink" title="LastPass：全端密码管理器"></a>LastPass：全端密码管理器</h3><p>跨平台的密码管理器。基本上吾辈在 Google Chrome 上使用 Plugin，在 Mobile 上也使用它。虽然 Google Chrome 自带了密码管理/同步功能，然而对于某些两步验证的网站并未能很好的支持，而且也不支持跨浏览器！而 LastPass 基本上免费版本对于个人使用算是绰绰有余了，支持密码同步，跨平台/跨浏览器支持，复杂密码一键生成。</p>
<blockquote>
<p>注：吾辈在 PC 上使用 Google Chrome，Mobile 上却使用 Mozilla Firefox。</p>
</blockquote>
<h3 id="PxView：Pixiv-第三方客户端"><a href="#PxView：Pixiv-第三方客户端" class="headerlink" title="PxView：Pixiv 第三方客户端"></a>PxView：Pixiv 第三方客户端</h3><p>Pixiv 第三方客户端。相比于官方客户端有很多收费功能。<br>主要特点如下</p>
<ul>
<li>无广告</li>
<li>开源</li>
<li>支持黑暗模式</li>
<li>允许查看排行</li>
<li>保存图片</li>
</ul>
<h3 id="MXPlayer：本地视频播放器"><a href="#MXPlayer：本地视频播放器" class="headerlink" title="MXPlayer：本地视频播放器"></a>MXPlayer：本地视频播放器</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://drive.google.com/open?id=1V7p6iGlIFLrOSgdpvbKX7jIF7hDeqPCg">Pro 破解版</a></p>
</blockquote>
<p>MxPlayer 应该算是 Android 上最强的本地播放器了吧？拥有相当多的解码器，对绝大多数的视频都能正常播放，对字幕的支持也相当不错，同时也能当作本地音乐播放器使用。</p>
<h3 id="静读天下：本地书籍阅读器"><a href="#静读天下：本地书籍阅读器" class="headerlink" title="静读天下：本地书籍阅读器"></a>静读天下：本地书籍阅读器</h3><blockquote>
<p>已入正</p>
</blockquote>
<p>非常好用的电子书阅读器，对多种格式的文档都支持的非常好。<br>包括但不限于以下格式</p>
<ul>
<li><code>Txt</code>：传统纯文本小说格式</li>
<li><code>HTML</code>：巨大网页小说，一般为二次导出</li>
<li><code>Epub</code>：新的电子书籍标准</li>
<li><code>Mobi</code>：亚马逊 Kindle 阅读器支持的专有格式</li>
<li><code>PDF</code>：Adobe 发行的一种电子书籍格式</li>
<li><code>umd</code>：常见的请小说格式</li>
<li><code>chm</code>：常见的电子文档格式</li>
</ul>
<p>交互友好，页面优雅，全能的本地阅读器。</p>
<h3 id="Weawow：天气-App"><a href="#Weawow：天气-App" class="headerlink" title="Weawow：天气 App"></a>Weawow：天气 App</h3><p>一个天气应用，使用它纯粹是不喜欢系统自带的天气应用。简单纯粹，不强制弹窗提醒升级，桌面的小部件也很简洁，最重要的是天气预报还算准确！</p>
<h3 id="InoReader：RSS-阅读器"><a href="#InoReader：RSS-阅读器" class="headerlink" title="InoReader：RSS 阅读器"></a>InoReader：RSS 阅读器</h3><p>一个跨平台的 RSS 阅读器，相比于大名鼎鼎的 <a target="_blank" rel="noopener" href="https://feedly.com/">Feedly</a> 有着更多的免费功能，而且对于用户的支持非常棒！</p>
<blockquote>
<p>附：吾辈之前就有遇到过 RSS 只有一部分内容，需要在浏览器打开才能看到全文的情况，InoReader 快速回答了呢！</p>
</blockquote>
<h3 id="YMusic：Youtube-的第三方音乐客户端"><a href="#YMusic：Youtube-的第三方音乐客户端" class="headerlink" title="YMusic：Youtube 的第三方音乐客户端"></a>YMusic：Youtube 的第三方音乐客户端</h3><p>Youtube 虽然好用，但 Android 版的广告实在实在实在太多了！因为很重要，所以说三遍。吾辈日常使用 Youtube 听音乐，然而 Youtube 不能后台播放，不能下载到本地的特性导致单纯的听音乐真的很麻烦。<br>而 YMusic 不仅能下载 Youtube 上的内容，而且还能登录 Google 账号同步 Youtube 的内容。这，便是使用 YMusic 的理由！</p>
<h3 id="Musicolet：本地音乐播放器"><a href="#Musicolet：本地音乐播放器" class="headerlink" title="Musicolet：本地音乐播放器"></a>Musicolet：本地音乐播放器</h3><p>简单便捷的本地播放器，官方承诺绝不联网，使用体验也不错，便使用了。</p>
<h3 id="CX-文件管理器：简单的文件管理器"><a href="#CX-文件管理器：简单的文件管理器" class="headerlink" title="CX 文件管理器：简单的文件管理器"></a>CX 文件管理器：简单的文件管理器</h3><p>讨厌 EX 的广告和自动更新，而且实际上也用不到那么多的功能，吾辈只想简单的浏览、分类文件，同时在手机上访问局域网内的电脑文件罢了。</p>
<h3 id="简易图库"><a href="#简易图库" class="headerlink" title="简易图库"></a>简易图库</h3><p>简单的图片管理器，上一个国产图片浏览 App 还是快图浏览 <code>0.8.*</code> 的时代，但它已经过时了，所以，吾辈找到了这个 – 简单，不联网，自带简单的图片编辑，足够了。</p>
<h3 id="Sleep-Cycle：睡眠分析和智能闹钟"><a href="#Sleep-Cycle：睡眠分析和智能闹钟" class="headerlink" title="Sleep Cycle：睡眠分析和智能闹钟"></a>Sleep Cycle：睡眠分析和智能闹钟</h3><p>一个睡眠分析 App，能帮助我了解睡眠状况，以此来找寻解决方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，关于吾辈在 mobile 上使用的 App 清单便到此结束了。如果你有什么有趣的 App，也可以推荐给吾辈哦</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/a7418dcc845e45c4b342cff1d6fefc61/" data-id="ckmcqox4c00710kuvf13p59g5" data-title="Android 常用 App 清单" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" rel="tag">待更新</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-a7d496697aae4cfb84777a64a69db755" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/a7d496697aae4cfb84777a64a69db755/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/a7d496697aae4cfb84777a64a69db755/">WebStorm 使用技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="WebStorm-全局默认配置"><a href="#WebStorm-全局默认配置" class="headerlink" title="WebStorm 全局默认配置"></a>WebStorm 全局默认配置</h2><p>使用场景：<br>使用 WebStorm 经常会遇到一种情况，在这个项目自顶了一些设置（<strong>Settings</strong> 而非 <strong>Project Structure</strong>，例如 自定义的 Maven，项目字符编码等等），到了新的项目全部恢复了默认值又要重新设定。</p>
<p>解决方案：<br>通过 WebStorm 的默认设置（<strong>File &gt; Other Settings &gt; Default Settings</strong>）就可以设定全局的 <strong>Settings</strong>，而不需要在每个项目中重新设定一次。</p>
<blockquote>
<p>默认设定按吾辈的理解应该是用于设定那些可以使项目级别的设置，例如 <strong>代码检查</strong>，<strong>代码样式</strong> 等。毕竟大部分的设置都是全局的嘛</p>
</blockquote>
<h2 id="Alt-Enter-操作提示"><a href="#Alt-Enter-操作提示" class="headerlink" title="Alt-Enter 操作提示"></a>Alt-Enter 操作提示</h2><p>Alter-Enter 大概是 WebStorm 最强大快捷键了，放在不同的位置有不同的功能。</p>
<ul>
<li>警告（代码下面有黄色波浪线），会自动帮我们修复警告。<br>代码重复，代码冗余（1/0 之类），多余的变量（声明完就立刻返回/声明完最多只使用了一次）</li>
<li>错误（代码下面有红色波浪线），一般会提出合适的修复建议。<br>代码缺少注解，具体子类有未实现的方法</li>
<li>接口名（接口的名字），一般会提示可以生成实现类或者跳转到实现类</li>
<li>自动修复变量名的问题（不符合驼峰）</li>
<li>普通类名，一般会提示创建测试类，没有 JavaDoc 注释还会提示生成注释</li>
<li>字符串里面，会提示使用 <a href="#%E8%AF%AD%E8%A8%80%E6%B3%A8%E5%85%A5">语言注入</a></li>
<li>跳转到注入语言的编辑面板</li>
</ul>
<h2 id="Double-Shift-任意搜索"><a href="#Double-Shift-任意搜索" class="headerlink" title="Double Shift 任意搜索"></a>Double Shift 任意搜索</h2><p>这个功能其实是集成了多个搜索，但有时候真的很好用，集成的功能包括</p>
<ul>
<li>搜索 <code>Settings</code>（<code>CS-A</code>）：搜索 WebStorm 的设置</li>
<li>搜索 <code>class</code>（<code>C-N</code>）：搜索代码里的 class 类</li>
<li>搜索 <code>File</code>（<code>CS-N</code>）：搜索任何文件</li>
<li>搜索 <code>symbol</code>（<code>CSA-N</code>）：搜索符号，主要用于搜索 Spring MVC 路径</li>
<li>搜索 <code>Tool Windows</code>（<code>C-Tab</code>）：搜索工具窗口</li>
<li>搜索 <code>Run configuration</code>（<code>SA-F9/F10</code>）：搜索运行的配置项</li>
<li>搜索 <code>Action</code>（<code>Alt-Enter</code>）：搜索当前位置的代码可执行操作</li>
</ul>
<p>如果你知道需要搜索的类型，请尽量使用单独的搜索选项，毕竟速度上会有一些优势</p>
<h2 id="列编辑"><a href="#列编辑" class="headerlink" title="列编辑"></a>列编辑</h2><p>列编辑是一个非常有趣的功能，可以让你同时编辑多行文本。</p>
<p>共有下面几种方式触发</p>
<ul>
<li>使用鼠标中键下拉或上拉选中多行</li>
<li>使用 <code>A-J</code> 依次选择相同的代码片段，并使用 <code>SA-J</code> 取消选择</li>
<li>使用 <code>CSA-J</code> 选中当前文件所有匹配的代码片段</li>
<li>使用 <code>CA-Top/Bottom</code> 向上或向下选择多行（需要添加快捷键 <code>Editor Actions =&gt; Clone Caret Above/Clone Caret Below</code>）</li>
</ul>
<p>GIF 演示</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190627110522.gif" alt="GIF 演示"></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p>快捷键想要熟练没有什么好的办法，却是只能多加使用了。如果你还不熟悉 WebStorm 的快捷键，可以使用 <a target="_blank" rel="noopener" href="https://github.com/halirutan/IntelliJ-Key-Promoter-X">Key Promoter X</a> 插件来提示你使用快捷键操作。</p>
</blockquote>
<ul>
<li>搜索<ul>
<li><code>C-N</code> ：搜索类</li>
<li><code>CS-N</code> ：搜索文件</li>
<li><code>CSA-N</code> ：搜索字段名(包含数据库字段)/方法名</li>
<li><code>SS</code> ：搜索接口路径，类名，文件名，字段名/方法名</li>
<li><code>CS-F</code>：全局搜索代码（该快捷键与 Windows10 的默认输入法冲突，可以修改快捷键，或者换用其他输入法）</li>
</ul>
</li>
<li>面板操作<ul>
<li><code>ESC</code>：返回到编辑器中</li>
<li><code>C-E</code> ：列出最近操作的文件历史以及可操作面板列表，然后可以通过输入单词跳转到对应的面板</li>
<li><code>C-Tab -&gt; *</code>：列出最近操作的文件历史以及可操作面板，并能通过单个字母导航到对应的操作面板（需要一直按住 <code>Ctrl</code>）</li>
<li><code>A-Top/Bottom/Left/Right</code> ：左右是切换标签页，上下是切换方法</li>
<li><code>F12</code> ：跳转到最后一个使用的面板</li>
<li><code>CS-F12</code> ：收起/显示所有面板</li>
<li><code>C-F12</code> ：在一个悬浮面板上列出所有字段/方法</li>
<li><code>A-F11</code>: 列出可以快速运行的任务，支持 <code>npm/gulp</code></li>
</ul>
</li>
<li>选择<ul>
<li><code>C-W/CS-W</code> ：扩大/缩小选择区域范围</li>
<li><code>CS-[/]</code>：选择至当前区域的开始/结束</li>
<li><code>A/SA-J</code> ：选中/反选相同的单词进行列编辑（一个个的选中）</li>
<li><code>CSA-J</code> ：选中多个相同的单词（当前文件全部选中）</li>
</ul>
</li>
<li>代码跳转<ul>
<li><code>CA-Left/Right</code> ：跳转到上一个/下一个浏览的位置</li>
<li><code>CS-Backspace</code> ：回退到上一个编辑的位置</li>
<li><code>C-Top/Bottom/Left/Right</code>：左右是跳转到上一个/下一个单词，上下是移动屏幕（非移动光标）</li>
<li><code>C-;</code> ：屏幕内任意跳转（需要安装 <strong>Ace Jumper</strong> 插件）</li>
<li><code>Home</code> ：跳转到行首/编辑器的最左侧</li>
<li><code>End</code> ：跳转到行尾</li>
<li><code>C-Home/End</code> ：跳转到文件的开始/结尾</li>
<li><code>C-Page Up/Page Down</code> ：跳转到当前屏幕的第一行/最后一行</li>
<li><code>F2/S-F2</code> ：跳转到下一个/上一个错误/警告的位置</li>
<li><code>C-Left/C-Right</code> ：跳转到上一个/下一个单词的位置</li>
<li><code>C-B</code> ：跳转到变量/方法的声明处</li>
<li><code>CS-B</code> ：跳转到变量/方法的具体实现处，如果不止一处就会列出下拉框<blockquote>
<p>注：这里吾辈修改了快捷键，毕竟 <code>CA-B</code> 单手按起来还真有点麻烦</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：在 WebStorm 看来左侧字母上面的数字键和右侧小键盘的数字键是不同的！<br>注: <code>Shift</code> 一般用于 <strong>增强/取反</strong> 功能。例如 <code>C-F</code> 搜索当前文件，<code>CS-F</code> 搜索所有文件，<code>F2</code> 跳转到下一个错误，<code>S-F2</code> 跳转到上一个错误。</p>
</blockquote>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ul>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/4441-jrebel-for-intellij">JRebel for IntelliJ</a>：做 Java Web 开发时真心免不了的 Plugin，能够有效解决 Web 容器（例如 Apache Tomcat）启动速度慢的问题（因为几乎所有的资源都能够热加载，热部署）</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7007-liveedit">LiveEdit</a>：提供了 HTML/CSS/JavaScript 的实时预览和刷新功能</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/10119-mybatisx">MybatisX</a>：Mybatis 的一个辅助开发插件，能够比较愉快的使用 Mybatis 框架了</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines">Alibaba Java Coding Guidelines</a>：Alibaba 出品的一个 Java 规范检查插件，能够规避一些不好的代码</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/8579-translation">Translation</a>：目前使用感觉最好的翻译插件，能够提供比较长的内容进行翻译（某些翻译插件只能翻译很短的内容）</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/2162-string-manipulation">String Manipulation</a>：字符串操作工具，可以方便对变量名或其他字符串修改为其他风格，例如将变量从 <strong>驼峰命名</strong>（Java 标准命名） 修改为 <strong>下划线命名</strong>（SQL 标准命名）或者 <strong>中缀线命名</strong>（HTML/CSS 标准命名）。<blockquote>
<p>其实这么多命名规范真心坑。。。</p>
</blockquote>
</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/9792-key-promoter-x">Key Promoter X</a>：使用鼠标操作时提示对应的快捷键</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/9862-custom-postfix-templates">Custom Postfix Templates</a>：提供自定义的后缀模板</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7896-markdown-navigator">Markdown Navigator</a>：WebStorm 平台的 Markdown 写作插件，比自带的 Markdown Support 要好很多，主要在需要写的 Markdown 内容中含有代码时比较方便</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7179-maven-helper">Maven Helper</a>：一个 Apache Maven 的辅助操作插件</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7275-codeglance">CodeGlance</a>：在编辑器右侧显示一块代码缩略图，主要为了方便使用滑块进行上下滑动</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7125-grep-console">Grep Console</a>：自定义控制台的输出颜色</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7495--ignore">.ignore</a>：在使用版本控制时，快速忽略某些文件/文件夹，目前支持广泛</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/5834-cmd-support">CMD support</a>：Cmd 支持，主要是方便在 WebStorm 中直接运行 bat 脚本</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/6098-nodejs">NodeJS</a>：集成了 NodeJS，可以直接在 WebStorm 中运行 NodeJS</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/9442-vue-js">Vue.js</a>：集成 Vue.js 框架</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7494-eslint">ESLint</a>：前端代码规范</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/10456-prettier">Prettier</a>：根据上面 ESLint 的规范自动格式化代码</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter">Properties to YAML Converter</a>：将 <code>Properties</code> 文件快速转换为 <code>YAML</code> 格式的配置文件</li>
<li><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7425-wakatime">WakaTime</a>：统计使用的编程语言，不同 IDE 的记录</li>
</ul>
<h2 id="语言注入"><a href="#语言注入" class="headerlink" title="语言注入"></a>语言注入</h2><p>为某一段区域的注入其他语言，WebStorm 最常见的就是在 JavaScript 的字符串中注入了 HTML/CSS/JavaScript，使得在字符串内也有代码提示可用。</p>
<blockquote>
<p>此功能常用于 JavaScript 字符串拼接 HTML 代码，当然目前这个需求在 ES6 中由 <code>模板字符串</code> 原生实现了。</p>
</blockquote>
<p>我们也可以手动注入，例如为 Java 中的字符串注入 SQL 语言，这样在写 SQL 语句就不用跑到 SQL 编辑器那里写完 SQL 语句在粘贴过来了。</p>
<h2 id="Live-Template-Postfix-Template-模板"><a href="#Live-Template-Postfix-Template-模板" class="headerlink" title="Live Template/Postfix Template 模板"></a>Live Template/Postfix Template 模板</h2><p>Live Template 模板就是那种在 Java 中输入 <code>sout</code> 就可以生成以下代码的模板功能，而这功能在 WebStorm 还可以自定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println($END$);</span><br></pre></td></tr></table></figure>
<p>例如吾辈就定义了 <code>autowired</code> 用于生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> $BeanClass$ $BeanName$;</span><br><span class="line">$END$</span><br></pre></td></tr></table></figure>
<p>或者 <code>thread</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    $END$</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>此功能使用得当甚至能大量减少重复编码。不过相比之下另外一个代码生成功能吾辈更加喜欢，但 WebStorm 在 2018.2 版本之前并不支持自定义，所以功能上来说就显得稍弱一些，当然吾辈也使用插件（Custom Postfix Templates <a target="_blank" rel="noopener" href="https://github.com/xylo/intellij-postfix-templates#download">GitHub</a>）实现了自定义的需求。最新版本 WebStorm 原生支持了自定义功能（<a target="_blank" rel="noopener" href="https://blog.jetbrains.com/idea/2014/03/postfix-completion/">WebStorm 官方介绍</a>），但实现尚不完善。</p>
<p>此功能可以做到另外一种形式的模板字符串，例如输入 <code>&quot;str&quot;.var</code> 然后回车会得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String $variableName$ = <span class="string">&quot;str&quot;</span>;$END$</span><br></pre></td></tr></table></figure>
<p>或者 <code>&quot;str&quot;.sout</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sysout.out.println(<span class="string">&quot;str&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>吾辈也自定义一些，例如输入了 <code>&quot;str&quot;.val</code>，会生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String $variableName$ = <span class="string">&quot;str&quot;</span>;$END$</span><br></pre></td></tr></table></figure>
<h2 id="一些有用的配置项"><a href="#一些有用的配置项" class="headerlink" title="一些有用的配置项"></a>一些有用的配置项</h2><h3 id="soft-wrap-强制换行"><a href="#soft-wrap-强制换行" class="headerlink" title="soft wrap 强制换行"></a>soft wrap 强制换行</h3><p>WebStorm 在一行过长时会出现横向滚动条，那我们不想要它出现以便于能直接使用键盘就能看完要怎么办呢？</p>
<p>可以在 <em>Settings ⇒ Editor ⇒ General ⇒ Soft Wraps</em> 中找到设置，将 <strong>Soft-wrap files</strong> 的值修改为 <code>*</code> 即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191212090747.png" alt="强制换行"></p>
<h3 id="根据源代码自动滚动项目"><a href="#根据源代码自动滚动项目" class="headerlink" title="根据源代码自动滚动项目"></a>根据源代码自动滚动项目</h3><p>可以在跳转文件时，使文件目录自动聚焦在当前编辑的文件上，这在很多时候是有利于查看目录/文件的。</p>
<p>2019.3 之后</p>
<p>在 <em>Project ⇒ Always Select Opened File</em> 中可以找到这个配置，启用即在整个项目中启用了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191224100414.png" alt="根据源代码自动滚动项目设置"></p>
<p>2019.3 之前</p>
<p>在 <em>Project ⇒ Tool ⇒ Autoscroll from Source</em> 中可以找到这个配置，启用即在整个项目中启用了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191212090627.png" alt="根据源代码自动滚动项目设置"></p>
<h2 id="复制-WebStorm-提示的报错"><a href="#复制-WebStorm-提示的报错" class="headerlink" title="复制 WebStorm 提示的报错"></a>复制 WebStorm 提示的报错</h2><blockquote>
<p>这个技巧的发现来源于一个同事</p>
</blockquote>
<p>有时候 WebStorm 提示我们错误，当我们把鼠标放在上面时会有一个 <code>Tooltip</code>。但当我们想要复制这个错误时，却发现选择时 <code>Tooltip</code> 很容易消失，即便在较新版本中进行了改进，但想要复制仍然是非常痛苦的一件事，那么如何更加简单的复制错误呢？<br>实际上，当我们将光标移动到错误上面时，左下角的状态栏中会有该错误并且可以右键复制！</p>
<p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200430145423.png" alt="复制 WebStorm ToolTip 提示"></p>
<blockquote>
<p>相关问题参考：<a target="_blank" rel="noopener" href="https://youtrack.jetbrains.com/issue/WebStorm-70943">https://youtrack.jetbrains.com/issue/WebStorm-70943</a>，这是一个相当古老（2011 年）的问题，但 JetBrains 的开发者一开始甚至不认为这是一个问题，直到最近才着手修复它。<br>附：或许 JetBrains 的开发人员并不需要面向 Google 编程？#笑</p>
</blockquote>
<h2 id="浏览器报错在-WebStorm-打开相应文件"><a href="#浏览器报错在-WebStorm-打开相应文件" class="headerlink" title="浏览器报错在 WebStorm 打开相应文件"></a>浏览器报错在 WebStorm 打开相应文件</h2><blockquote>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903967206408206">React 调试的时候如何打开指定的编辑器 /webstorm</a></li>
</ul>
</blockquote>
<p>react 项目下其实就是添加环境变量 <code>REACT_EDITOR</code> 而已，可以使用 <code>.env.local</code> 进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REACT_EDITOR&#x3D;[WebStorm 的路径]</span><br></pre></td></tr></table></figure>
<h2 id="设定默认-jest-运行单元测试"><a href="#设定默认-jest-运行单元测试" class="headerlink" title="设定默认 jest 运行单元测试"></a>设定默认 jest 运行单元测试</h2><p>在包含 react-scripts 依赖的项目中，WebStorm 会默认使用 react-scripts 运行测试，这在单体项目中当然很好，但如果是 monorepo，则会出现一些问题。react-scripts 运行时会强制修改 <code>tsconfig.json/react-app-env.d.ts</code>，这在一些 node 子模块中会出现问题，而 react-scripts 目前还不能关闭这个功能。所以只能修改 WebStorm 的测试运行工具了，可以在 <code>Edit configuration</code> 中修改 <code>Jest =&gt; Jest Package</code> 字段值为 <code>jest</code>，更推荐设置 <code>Templates =&gt; Jest =&gt; Jest Package</code> 字段，因为它可以一劳永逸。</p>
<p><img src="/images/9697e0ecf2a94558953c1bb4117ce641.png" alt="1615086542056"></p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/53794875">How to configure react-script so that it doesn’t override tsconfig.json on ‘start’</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/a7d496697aae4cfb84777a64a69db755/" data-id="ckmcqox4c00730kuvhk0y1lqi" data-title="WebStorm 使用技巧" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webstorm/" rel="tag">webstorm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-a8524fe9f9e646e284638c4ddf0bda50" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/a8524fe9f9e646e284638c4ddf0bda50/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/a8524fe9f9e646e284638c4ddf0bda50/">点击按钮自动提交了 Form 表单</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在吾辈的写 HTML 时遇到了一个问题，一个普通的按钮，点击之后一旦在 <code>click</code> 事件中进行了 <code>return</code>，则立刻提交 <code>Form</code> 表单。</p>
<p>像下面这段代码，不管是点击 <em>修改按钮</em> 还是 _提交按钮_，<code>Form</code> 表单都会被提交（可以看到 <code>alert</code> 弹框）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;submitFn()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;文本输入框&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;updateFn()&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 提交方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">submitFn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;form 表单被提交了&quot;</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 修改方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">updateFn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $username = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#form &gt; input&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!$username.value) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    $username.value = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>后来经过同事提醒，在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button#%E5%B1%9E%E6%80%A7">MDN</a> 找到了关于 <code>button</code> 按钮的解释，在 <em>属性 =&gt; type</em> 小结中，有下面这样一段内容</p>
<blockquote>
<p><strong>type</strong><br>button 的类型。可选值：</p>
<ul>
<li><code>submit</code>: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。</li>
<li><code>reset</code>: 此按钮重置所有组件为初始值。</li>
<li><code>button</code>: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。</li>
<li><code>menu</code>: 此按钮打开一个由指定 <code>&lt;menu&gt;</code> 元素进行定义的弹出菜单。</li>
</ul>
</blockquote>
<p>是的，当没有指定 <code>button</code> 元素的 <code>type</code> 属性时，浏览器将默认为 <code>submit</code> 而非 <code>button</code>，导致了在 <code>Form</code> 表单中容易出现奇怪的自动提交问题。</p>
<p>修改后的代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;submitFn()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;文本输入框&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 实际上只是在这里加了一个 type=&quot;button&quot; 属性而已 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;updateFn()&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 提交方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">submitFn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&quot;form 表单被提交了&quot;</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 修改方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">updateFn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $username = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#form &gt; input&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!$username.value) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    $username.value = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上吾辈也只添加了一个 <code>type</code> 属性，但却因为这个问题耗费许久，终归是基础知识的坑踩得不够多。不过幸好，吾辈可以记录下来，避免在同一个坑里跌倒两次！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/a8524fe9f9e646e284638c4ddf0bda50/" data-id="ckmcqox4d00760kuv2e0v3cfq" data-title="点击按钮自动提交了 Form 表单" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-abe6253bc476414a99d37233c0c71c3e" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/abe6253bc476414a99d37233c0c71c3e/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/abe6253bc476414a99d37233c0c71c3e/">一些烦心事</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p>抽刀断水水更流，举杯消愁愁更愁（虽然吾辈并不喝酒就是了）</p>
</blockquote>
<p>明明说过这是一个技术博客的，然而现如今，吾辈却也需要发一些技术之外的内容了呢。。。（经受了<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/282036368">社会的毒打</a>）</p>
<h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212832.png" alt="公司"></p>
<p>最近到了一家新的公司，每天早晨 6-7 点起床，然后晚上 7-8 点回来，忙忙碌碌，再无他事。</p>
<p>公司项目历史遗留的问题之多，想要改变问题面临的困境之难，都导致吾辈在公司的时间逐渐变多，自己生活的时间逐渐变少，所以最近别说博客都半个月不发一次，连 github 的维护都少有时间，每天都是早晨抽空维护半个小时罢了。</p>
<p>回到了家里，吃完晚饭，洗完澡，便已然快到了睡觉的时间。想要做点自己的事情，但又感觉没什么时间。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212906.png" alt="生活"></p>
<p>而且，现在吾辈有点控制不了时间了，每天睡觉时间也难以固定。或许因为一时兴起，便去看了一部电影，然后到了凌晨 0 点或 1 点再睡觉，便是在周末刻意进行了补觉，但也不能弥补日常精力不足的事实。</p>
<p>不曾被在意，不曾被了解，没有目标，没有动力。吾辈曾经把写博客作为目标，但后来知识的增长速度越来越慢，空闲时间越来越多用来咸鱼般的躺在床上，发呆地度过周末的两天。</p>
<h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212931.png" alt="家庭"></p>
<p>曾经亲密的家人，现在因为一些事情，却也有了现实的矛盾。或许，家家都有难念的经，便是吾辈，也必须经历各种现实中的苦难吧。</p>
<p>周末有时回到家里，虽然家人现在没有说什么特别的话，但从他们的语气中，对我如今的现状，包含心疼，包含不满。如今也便只是维持现状，小心翼翼的计算每个月回去一次，便不会引起太多的波澜（无论如何亲密的人，只要待在一起的时间够久，便会发现对方的缺陷，而家人，便是能够忍受这种问题的存在）。</p>
<p>吾辈的妹妹已然让父母伤透了心，吾辈不想再伤害他们一次。然而屁股决定脑袋，吾辈想要的东西和他们想要的并不一致，它们的经验并不适合吾辈。娶妻生子，掌家立业，难道便是人一辈子的追求么？</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212955.png" alt="未来"></p>
<p>不知道未来会变成怎样，不知道未来会发生什么。平凡的活着，不断遭受着社会的毒打。当垂垂老矣时，回顾一生，没有任何值得诉说的事迹，或许也是吾辈一种可能的结局吧</p>
<blockquote>
<p>卑鄙有卑鄙者的通行证，高尚有高尚者的墓志铭。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/abe6253bc476414a99d37233c0c71c3e/" data-id="ckmcqox4f007d0kuv842ubwl1" data-title="一些烦心事" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ad1c52ed52954ad2ba4cf28785cb063f" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/ad1c52ed52954ad2ba4cf28785cb063f/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/ad1c52ed52954ad2ba4cf28785cb063f/">jsdoc 注释标签一览</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="速览表格"><a href="#速览表格" class="headerlink" title="速览表格"></a>速览表格</h2><h3 id="标签列表"><a href="#标签列表" class="headerlink" title="标签列表"></a>标签列表</h3><table>
<thead>
<tr>
<th>标签</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>param</code></td>
<td>参数</td>
</tr>
<tr>
<td><code>returns</code></td>
<td>返回值</td>
</tr>
<tr>
<td><code>example</code></td>
<td>示例</td>
</tr>
<tr>
<td><code>test</code></td>
<td>测试代码</td>
</tr>
<tr>
<td><code>class</code></td>
<td>类定义</td>
</tr>
<tr>
<td><code>property</code></td>
<td>类属性定义</td>
</tr>
</tbody></table>
<h3 id="语法列表"><a href="#语法列表" class="headerlink" title="语法列表"></a>语法列表</h3><table>
<thead>
<tr>
<th>语法</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;T&#125;</code></td>
<td>类型</td>
</tr>
<tr>
<td><code>&#123;T,R&#125;</code></td>
<td>多个类型</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>可选值</td>
</tr>
<tr>
<td><code>[arg=v]</code></td>
<td>默认值</td>
</tr>
<tr>
<td><code>.&lt;T&gt;</code></td>
<td>泛型</td>
</tr>
<tr>
<td><code>obj.property</code></td>
<td>对象参数</td>
</tr>
<tr>
<td><code>function(T):R</code></td>
<td>函数参数</td>
</tr>
</tbody></table>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="param"><a href="#param" class="headerlink" title="param"></a><code>param</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在控制台上打印一个值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>obj 需要被打印的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="returns"><a href="#returns" class="headerlink" title="returns"></a><code>returns</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个 0-1 之间的随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a><code>example</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个 0-1 之间的随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>随机数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * const i = random()</span></span><br><span class="line"><span class="comment"> * console.log(i)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a><code>test</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@test <span class="type">&#123;random&#125;</span> </span>测试 random 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">describe(<span class="string">&quot;测试 random 函数&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&quot;测试两次随机数是否相等&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> i = random();</span><br><span class="line">    <span class="keyword">const</span> k = random();</span><br><span class="line">    expect(i).not.toBe(k);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a><code>class</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单模拟 Vue class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class <span class="variable">Vue</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a><code>property</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单模拟 Vue class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class <span class="variable">Vue</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123;String|Element&#125;</span> </span>option.el 实例绑定的 DOM 选择器或元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123;Object|Function&#125;</span> </span>[option.data=&#123;&#125;] 实例内部绑定的数据，默认为空对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123;Object&#125;</span> </span>[option.methods=&#123;&#125;] 实例的方法对象，默认为空对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property <span class="type">&#123;Function&#125;</span> </span>[option.mounted=function() &#123;&#125;] 实例的初始化函数，默认为空函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>option 可选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String|Element&#125;</span> </span>option.el 实例绑定的 DOM 选择器或元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object|Function&#125;</span> </span>[option.data=&#123;&#125;] 实例内部绑定的数据，默认为空对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[option.methods=&#123;&#125;] 实例的方法对象，默认为空对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[option.mounted=function() &#123;&#125;] 实例的初始化函数，默认为空函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; el, data = &#123;&#125;, methods = &#123;&#125;, mounted = <span class="keyword">function</span> () &#123;&#125; &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.el = el;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.methods = methods;</span><br><span class="line">    <span class="built_in">this</span>.mounted = mounted;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id=""><a href="#" class="headerlink" title="{}"></a><code>&#123;&#125;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算两个数字之和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>i 第一个数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>k 第二个数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number&#125;</span> </span>两数之和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">i, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i + k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T-R"><a href="#T-R" class="headerlink" title="{T,R}"></a><code>&#123;T,R&#125;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算两个数字之和，或者两个字符串之间的连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|String&#125;</span> </span>i 第一个数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|String&#125;</span> </span>k 第二个数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number|String&#125;</span> </span>两数之和，或者两个字符串之间的连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">i, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i + k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title="[]"></a><code>[]</code></h3><p>使用场景: 可选参数不需要在函数中所有条件下使用</p>
<p>例如下面的 <code>sep</code> 在不传入时会默认返回 <code>[str]</code>，一般优先使用 <code>[arg=v]</code> 更好</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割字符串为数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>str 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>[sep] 分隔符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span> </span>分割后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str, sep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sep ? str.split(sep) : [str];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arg-v"><a href="#arg-v" class="headerlink" title="[arg=v]"></a><code>[arg=v]</code></h3><p>使用场景: 需要为传入的参数赋予默认值</p>
<blockquote>
<p>注: 太过冗长的默认值最好使用文件描述而非加到 <code>[]</code> 中</p>
</blockquote>
<p>例如下面的函数参数 <code>sep</code>，如果想要在不传入的时候默认为 <code>&#39;&#39;</code>，就需要使用默认值标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割字符串为数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>str 字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>[sep=&#x27;&#x27;] 分隔符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array&#125;</span> </span>分割后的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str, sep = <span class="string">&quot;&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(sep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lt-T-gt"><a href="#lt-T-gt" class="headerlink" title=".&lt;T&gt;"></a><code>.&lt;T&gt;</code></h3><p>使用场景: <code>Array, Map, Set, Iterator</code> 这中集合接口/类限定元素类型，也有 <code>Promise</code> 这种内嵌其他类型异步结果的情况</p>
<p>例如下面的集合就声明元素全部都需要为 <code>String</code>，<code>Object</code> 的话可能出现 <code>[object Object]</code> 这种内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 String 类型的数组中的元素都连接起来，并以逗号进行分割</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array.&lt;String&gt;&#125;</span> </span>arr 字符串数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;String&#125;</span> </span>连接后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="obj-property"><a href="#obj-property" class="headerlink" title="obj.property"></a><code>obj.property</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单模拟 Vue API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>option 可选项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String|Element&#125;</span> </span>option.el 实例绑定的 DOM 选择器或元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object|Function&#125;</span> </span>[option.data=&#123;&#125;] 实例内部绑定的数据，默认为空对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[option.methods=&#123;&#125;] 实例的方法对象，默认为空对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[option.mounted=function() &#123;&#125;] 实例的初始化函数，默认为空函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">&#123; el, data = &#123;&#125;, methods = &#123;&#125;, mounted = <span class="keyword">function</span> () &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.el = el;</span><br><span class="line">  <span class="built_in">this</span>.data = data;</span><br><span class="line">  <span class="built_in">this</span>.methods = methods;</span><br><span class="line">  <span class="built_in">this</span>.mounted = mounted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="function-T-R"><a href="#function-T-R" class="headerlink" title="function(T):R"></a><code>function(T):R</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自行实现 flatMap，将数组压平一层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array.&lt;Object&gt;&#125;</span> </span>arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function(Object):Array&#125;</span> </span>fn 映射方法，将一个元素映射为一个数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Array.&lt;Object&gt;&#125;</span> </span>压平一层的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flatMap</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">res, item</span>) =&gt;</span> res.concat(fn(item)), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--
## 问题

### 如何处理对象参数

### 如何处理函数参数

### 如何处理自定义类型参数

### 如何定义类型保证参数及返回值泛型相同

### 如何标记测试代码
-->

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/ad1c52ed52954ad2ba4cf28785cb063f/" data-id="ckmcqox4g007h0kuv8mhz6wra" data-title="jsdoc 注释标签一览" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-b868601482c94fa884ca706e47a41dff" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/b868601482c94fa884ca706e47a41dff/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/b868601482c94fa884ca706e47a41dff/">JavaScript 使用 Promise</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>为什么要使用 Promise？</p>
<p>JavaScript 异步发展史：<code>回调函数 -&gt; Promise -&gt; async/await</code></p>
<p>传统异步使用回调函数，回调意味着嵌套，当你需要使用很多异步函数时，那你需要非常多的回调函数，可能形成回调地狱。<br>有问题就有人解决，js 没有多线程，所以天生就是异步的。正是因为异步的广泛性，所以很早之前就有人着力于解决异步回调的问题，github 上有很多已经废弃的库就是用于解决这个问题的。<br>然而现在，es6 出现了 <code>Promise</code>，它能把嵌套回调压平为一层的链式调用，并且写进了 js 标准里。es7 甚至出现了更加优雅的方式，<code>async/await</code>，能以同步的方式写异步的代码。当然，本质上只是 Promise 的一个语法糖，但其重要性也是不言而喻的——异步回调地狱已经不存在了！<br>说了这么多，那么平常我们应该怎么使用 Promise 呢？</p>
<h2 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h2><p>一般而言，我们作为使用者是无需创建 Promise 的，支持 Promise 的函数会返回一个 Promise 对象给我们，然后我们使用它的方法 <code>then/catch</code> 即可。</p>
<ul>
<li><code>then()</code>：当前的 JavaScript 已经完成，要进行下一步的同步/异步操作了</li>
<li><code>catch()</code>：用于捕获 Promise 链式调用中可能出现的错误</li>
</ul>
<blockquote>
<p>注：<code>then/catch</code> 均返回一个新的 Promise</p>
</blockquote>
<p>例如我们有这样一个需求</p>
<ol>
<li> 等待资源 A 加载完成</li>
<li> 在 A 资源加载完成之后等待 B 资源加载完成</li>
</ol>
<p>之前使用回调函数，我们的代码可能是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>callback 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, param);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(</span><br><span class="line">  () =&gt; <span class="built_in">document</span>.querySelector(<span class="string">&quot;#a&quot;</span>),</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    wait(</span><br><span class="line">      () =&gt; <span class="built_in">document</span>.querySelector(<span class="string">&quot;#b&quot;</span>),</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;a, b 两个资源已经全部加载完成&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// a, b 两个资源已经全部加载完成</span></span><br></pre></td></tr></table></figure>
<p>可以看到，上面如果还需要等待 <code>c,d,e,f...</code> 资源，那么回调函数的层级将是无法接受的。<br>现在，我们使用 Promise 改造一下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先不要管这个函数的具体实现，下面再说如何自己封装 Promise</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(<span class="function">() =&gt;</span> <span class="built_in">document</span>.querySelector(<span class="string">&quot;#a&quot;</span>))</span><br><span class="line">  <span class="comment">// 注意这里的 wait(() =&gt; document.querySelector(&#x27;#b&#x27;)) 同样是一个异步函数，返回了一个 Promise</span></span><br><span class="line">  <span class="comment">// 接下来，有趣的地方来了</span></span><br><span class="line">  <span class="comment">// 很明显，wait 是一个异步函数。wait 函数的 then 函数调用了另一个异步函数，然而 then 会等待异步执行完成，才继续执行后面的函数</span></span><br><span class="line">  .then(<span class="function">() =&gt;</span> wait(<span class="function">() =&gt;</span> <span class="built_in">document</span>.querySelector(<span class="string">&quot;#b&quot;</span>)))</span><br><span class="line">  <span class="comment">// 这里仍然会等待上面的 Promise 完成之后才执行下面的内容</span></span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;a, b 两个资源已经全部加载完成&quot;</span>));</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// a, b 两个资源已经全部加载完成</span></span><br></pre></td></tr></table></figure>
<p>下面我们尝试使用一下 <code>catch</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wait(<span class="function">() =&gt;</span> <span class="built_in">document</span>.querySelector(<span class="string">&quot;#a&quot;</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> wait(<span class="function">() =&gt;</span> <span class="built_in">document</span>.querySelector(<span class="string">&quot;#b&quot;</span>)))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;执行了某些操作发生了异常&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 上面抛出了异常并且没有使用 catch 处理的话就会继续找下一个调用，直到找到处理的 catch，或者调用结束为止</span></span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;a, b 两个资源已经全部加载完成&quot;</span>))</span><br><span class="line">  <span class="comment">// 捕获上面的 then() 发生的异常，保证后面的调用正常执行</span></span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;使用 catch 捕获的异常: &quot;</span>, error))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;测试异步函数结束&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">// 使用 catch 捕获的异常:  Error: 执行了某些操作发生了异常</span></span><br><span class="line"><span class="comment">//     at wait.then.then (&lt;anonymous&gt;:4:11)</span></span><br><span class="line"><span class="comment">// VM272:9 测试异步函数结束</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以参考 MDN 上的教程 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用 Promises</a></p>
</blockquote>
<h2 id="封装-Promise"><a href="#封装-Promise" class="headerlink" title="封装 Promise"></a>封装 Promise</h2><p>那么，你是否也对上面自定义的 <code>wait</code> 函数感到好奇呢？我们来详细的了解一下具体如何做到的吧！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里返回了一个 Promise 对象，Promise 的构造函数要求一个函数参数</span></span><br><span class="line">  <span class="comment">// 函数的参数实际上有两个，resolve 和 reject，分别代表 [已经完成] 和 [出现错误]</span></span><br><span class="line">  <span class="comment">// 注：这个函数是立刻执行的，当 resolve 或 reject 执行时，这个 Promise 算是结束了，将进入下一个 then/catch 调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          <span class="comment">// 这里执行了代码，如果有什么结果需要传递给下一个调用，则直接放到 resolve 函数内即可</span></span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以使用 Promise 封装其他函数</p>
<ul>
<li><code>timeout</code>：一个简单的 <code>setTimeout()</code> 的封装</li>
<li><code>readLocal</code>：读取本地浏览器选择的文件</li>
<li><code>timing</code>：测试函数执行的时间，不管是同步还是异步的(Promise)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Promise 简单封装 setTimeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>ms 等待时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取本地浏览器选择的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;File&#125;</span> </span>file 选择的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;&#123;String&#125;</span></span>&#125; init 一些初始选项，目前只有 type 一项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>返回了读取到的内容（异步）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> readLocal = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="function">(<span class="params">file, &#123; type = <span class="string">&quot;readAsDataURL&quot;</span> &#125; = &#123;&#125;</span>) =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        reject(<span class="string">&quot;file not exists&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">      fr.onload = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(event.target.result);</span><br><span class="line">      &#125;;</span><br><span class="line">      fr.onerror = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125;;</span><br><span class="line">      fr[type](file);</span><br><span class="line">    &#125;);</span><br><span class="line">  result.DataURL = <span class="string">&quot;readAsDataURL&quot;</span>;</span><br><span class="line">  result.Text = <span class="string">&quot;readAsText&quot;</span>;</span><br><span class="line">  result.BinaryString = <span class="string">&quot;readAsBinaryString&quot;</span>;</span><br><span class="line">  result.ArrayBuffer = <span class="string">&quot;readAsArrayBuffer&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试函数的执行时间</span></span><br><span class="line"><span class="comment"> * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>fn 需要测试的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Number|Promise&#125;</span> </span>执行的毫秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timing</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> begin = performance.now();</span><br><span class="line">  <span class="keyword">const</span> result = fn();</span><br><span class="line">  <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> performance.now() - begin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.then(<span class="function">() =&gt;</span> performance.now() - begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>吾辈建议你也可以封装一些常用的异步函数，下面会展示 JavaScript 中如何更简单的使用异步！</p>
<h2 id="使用-async-await"><a href="#使用-async-await" class="headerlink" title="使用 async/await"></a>使用 async/await</h2><ul>
<li><code>async</code>：用于标识一个函数是异步函数，默认这个函数将返回一个 Promise 对象</li>
<li><code>await</code>：用于在 async 函数内部使用的关键字，标识一个返回 Promise 的异步函数需要等待</li>
</ul>
<p>使用 <code>async/await</code> 重构上面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 等待异步函数执行完成</span></span><br><span class="line">  <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> <span class="built_in">document</span>.querySelector(<span class="string">&quot;#a&quot;</span>));</span><br><span class="line">  <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> <span class="built_in">document</span>.querySelector(<span class="string">&quot;#b&quot;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a, b 两个资源已经全部加载完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注：init() 函数将返回一个 Promise，我们可以继续追加下一步的操作</span></span><br><span class="line">init();</span><br></pre></td></tr></table></figure>
<p>是的，就是如此简单，直接在异步函数添加 <code>await</code> 关键字就好了！</p>
<hr>
<p>最后，如果你要使用这些特性，请务必使用 babel 转换器。毕竟，有太多的人就是不肯升级浏览器。。。</p>
<blockquote>
<p>可以参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/">babeljs 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.rxliuli.com/p/e73e3322/">在传统项目中使用 babel 编译 ES6</a></li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/b868601482c94fa884ca706e47a41dff/" data-id="ckmcqox4m007z0kuv7vdten0a" data-title="JavaScript 使用 Promise" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-bd842060067c45708d8c08f89c9fcf4c" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/bd842060067c45708d8c08f89c9fcf4c/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/bd842060067c45708d8c08f89c9fcf4c/">使用 rollup 打包 JavaScript SDK</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>吾辈已经写了一个 TypeScript/JavaScript Cli 工具 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/liuli-cli">liuli-cli</a>，如有需要可以使用这个 Cli 直接生成一个开箱即用 SDK 项目，然后就可以直接开始写自己的代码，不需要太过关心下面的内容了 – 因为，它们都已然集成了。</p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="为什么要使用打包工具"><a href="#为什么要使用打包工具" class="headerlink" title="为什么要使用打包工具"></a>为什么要使用打包工具</h3><p>如果我们想要写一个 <code>JavaScript SDK</code>，那么就不太可能将所有的代码都写到同一个 js 文件中。当然了，想做的话的确可以做到，但随着 <code>JavaScript SDK</code> 内容的增加，一个 js 文件容易造成开发冲突，以及测试上的困难，这也是现代前端基本上都依赖于打包工具的原因。</p>
<h3 id="为什么打包工具是-rollup"><a href="#为什么打包工具是-rollup" class="headerlink" title="为什么打包工具是 rollup"></a>为什么打包工具是 rollup</h3><p>现今最流行的打包工具是 <a target="_blank" rel="noopener" href="https://webpack.js.org/">webpack</a>，然而事实上对于单纯的打包 JavaScript SDK 而言 webpack 显得有些太重了。webpack 终究是用来整合多种类型的资源而产生的（<code>ReactJS/VueJS/Babel/TypeScript/Stylus</code>），对于纯 JavaScript 库而言其实并没有必要使用如此 <strong>强大</strong> 的工具。而 rollup 就显得小巧精致，少许配置就能立刻打包了。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote>
<p>该记录的代码被吾辈放到了 <a target="_blank" rel="noopener" href="https://github.com/rxliuli/rollup-example">GitHub</a>，有需要的话可以看下。</p>
</blockquote>
<h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>开始之前，我们必须要对以下内容有所了解</p>
<ul>
<li>[x] JavaScript</li>
<li>[x] npm</li>
<li>[ ] babel</li>
<li>[ ] uglify</li>
<li>[ ] eslint</li>
</ul>
<h3 id="需要打包的代码"><a href="#需要打包的代码" class="headerlink" title="需要打包的代码"></a>需要打包的代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/wait.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待指定的时间/等待指定表达式成立</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number|Function&#125;</span> </span>param 等待时间/等待条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>Promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, param);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (param()) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/fetchTimeout.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 fetch 请求添加超时选项</span></span><br><span class="line"><span class="comment"> * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Promise&#125;</span> </span>fetchPromise fetch 请求的 Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchTimeout</span>(<span class="params">fetchPromise, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> abortFn = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//这是一个可以被 reject 的 Promise</span></span><br><span class="line">  <span class="keyword">var</span> abortPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    abortFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;abort promise&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 有一个 Promise 完成就立刻结束</span></span><br><span class="line">  <span class="keyword">var</span> abortablePromise = <span class="built_in">Promise</span>.race([fetchPromise, abortPromise]);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    abortFn();</span><br><span class="line">  &#125;, timeout);</span><br><span class="line">  <span class="keyword">return</span> abortablePromise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchTimeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> wait <span class="keyword">from</span> <span class="string">&quot;./wait&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> fetchTimeout <span class="keyword">from</span> <span class="string">&quot;./fetchTimeout&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限制并发请求数量的 fetch 封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchLimiting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; timeout = <span class="number">10000</span>, limit = <span class="number">10</span> &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    <span class="built_in">this</span>.execCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待队列</span></span><br><span class="line">    <span class="built_in">this</span>.waitArr = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行一个请求</span></span><br><span class="line"><span class="comment">   * 如果到达最大并发限制时就进行等待</span></span><br><span class="line"><span class="comment">   * 注：该方法的请求顺序是无序的，与代码里的顺序无关</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInfo&#125;</span> </span>url 请求 url 信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;RequestInit&#125;</span> </span>init 请求的其他可选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns <span class="type">&#123;Promise&#125;</span> </span>如果超时就提前返回 reject, 否则正常返回 fetch 结果</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">_fetch</span>(<span class="params">url, init</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> _innerFetch = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`执行 execCount: <span class="subst">$&#123;<span class="built_in">this</span>.execCount&#125;</span>, waitArr length: <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="built_in">this</span>.waitArr.length</span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>, index: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.waitArr[<span class="number">0</span>])&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">this</span>.execCount++;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">this</span>.waitArr.shift(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> fetchTimeout(fetch(...args), <span class="built_in">this</span>.timeout);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.execCount--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.waitArr.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="function">() =&gt;</span> <span class="built_in">this</span>.execCount &lt; <span class="built_in">this</span>.limit);</span><br><span class="line">    <span class="comment">// 尝试启动等待队列</span></span><br><span class="line">    <span class="keyword">return</span> _innerFetch();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FetchLimiting;</span><br></pre></td></tr></table></figure>
<h3 id="使用-rollup-直接打包"><a href="#使用-rollup-直接打包" class="headerlink" title="使用 rollup 直接打包"></a>使用 rollup 直接打包</h3><p>安装 <code>rollup</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i rollup -D</span><br></pre></td></tr></table></figure>
<p>在根目录创建一个 <code>rollup.config.js</code> 配置文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  input: <span class="string">&quot;src/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包名称</span></span><br><span class="line">    name: <span class="string">&quot;bundlea&quot;</span>,</span><br><span class="line">    <span class="comment">// 打包的文件</span></span><br><span class="line">    file: <span class="string">&quot;dist/bundle.js&quot;</span>,</span><br><span class="line">    <span class="comment">// 打包的格式，umd 支持 commonjs/amd/life 三种方式</span></span><br><span class="line">    format: <span class="string">&quot;umd&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>添加一个 <code>npm script</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;rollup -c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>npm run build</code> 测试打包，可以看到 <em>dist</em> 目录下已经有 <code>bundle.js</code> 文件了</p>
<blockquote>
<p>好了，到此为止我们已经简单使用 rollup 打包 js 了，下面的内容都是可选项，如果需要可以分节选读。</p>
</blockquote>
<h3 id="使用-babel-转换-ES5"><a href="#使用-babel-转换-ES5" class="headerlink" title="使用 babel 转换 ES5"></a>使用 babel 转换 ES5</h3><p>然而，我们虽然已经将 main.js 打包了，然而实际上我们的代码没有发生什么变化。即：原本是 ES6 的代码仍然会是 ES6，而如果我们想要尽可能地支持更多的浏览器，目前而言还是需要兼容到 ES5 才行。</p>
<p>所以，我们需要 <code>babel</code>，它能够帮我们把 ES6 的代码编译成 ES5。</p>
<blockquote>
<p>附：babel 被称为现代前端的 jquery。</p>
</blockquote>
<p>首先，安装 babel 需要的包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D rollup-plugin-babel @babel/core @babel/plugin-external-helpers @babel/preset-env</span><br></pre></td></tr></table></figure>
<p>在 <code>rollup.config.js</code> 中添加 <code>plugins</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-babel&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入 babel 插件</span></span><br><span class="line">    babel(&#123;</span><br><span class="line">      exclude: <span class="string">&quot;node_modules/**&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>添加 babel 的配置文件 <code>.babelrc</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [<span class="string">&quot;@babel/plugin-external-helpers&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再重新运行 <code>npm run build</code>，可以看到 <code>bundle.js</code> 中的代码已经被编译成 ES5 了。</p>
<h3 id="使用-uglify-压缩生产环境代码"><a href="#使用-uglify-压缩生产环境代码" class="headerlink" title="使用 uglify 压缩生产环境代码"></a>使用 uglify 压缩生产环境代码</h3><p>那么，生产中的代码还需要做什么呢？是的，压缩，减小 js 代码的体积是必要的。接下来，我们还需要使用 <code>uglify</code> 压缩我们打包后的 <code>bundle.js</code> 代码。</p>
<p>首先仍然是安装 <code>uglify</code> 相关的包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D rollup-plugin-uglify</span><br></pre></td></tr></table></figure>
<p>然后在 <code>rollup.config.js</code> 中引入插件就好了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，这里引入需要使用 &#123; uglify &#125; 而非 uglify，因为 uglify 导出自身时使用的是 exports.uglify</span></span><br><span class="line"><span class="keyword">import</span> &#123; uglify &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-uglify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// js 压缩插件，需要在最后引入</span></span><br><span class="line">    uglify(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用-ESLint-检查代码"><a href="#使用-ESLint-检查代码" class="headerlink" title="使用 ESLint 检查代码"></a>使用 ESLint 检查代码</h3><p>如果我们想要需要多人协作统一代码风格，那么可以使用 ESLint 来强制规范。</p>
<p>首先，全局安装 <code>eslint</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint -g</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>eslint cli</code> 初始化</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>
<p>下面的三项问题选择</p>
<ol>
<li>How would you like to configure ESLint? (Use arrow keys)<br> <code>Use a popular style guide</code></li>
<li>Which style guide do you want to follow? (Use arrow keys)<br> <code>Standard (https://github.com/standard/standard)</code></li>
<li>What format do you want your config file to be in? (Use arrow keys)<br> <code>JavaScript</code></li>
<li>Would you like to install them now with npm?<br> <code>y</code></li>
</ol>
<p>然后，我们发现项目根目录下多出了 <code>.eslintrc.js</code>，这是 eslit 的配置文件。然而，我们需要对其稍微修改一下，不然如果我们的代码中出现了浏览器中的对象，例如 <code>document</code>，eslint 就会傻傻的认为那是个错误！<br>修改后的 <code>.eslintrc.js</code> 配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="comment">// 添加了运行环境设定，设置 browser 为 true</span></span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们查看打包后的 <code>bundle.js</code> 时发现 eslint 给我们报了一堆错误，所以我们需要排除掉 dist 文件夹<br>添加 <code>.eslintignore</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist</span><br></pre></td></tr></table></figure>
<p>添加 <code>rollup-plugin-eslint</code> 插件，在打包之前进行格式校验</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D rollup-plugin-eslint</span><br></pre></td></tr></table></figure>
<p>然后引入它</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eslint &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-eslint&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入 eslint 插件</span></span><br><span class="line">    eslint(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个时候，当你运行 <code>npm run build</code> 的时候，eslint 可能提示你一堆代码格式错误，难道我们还要一个个的去修复么？不，eslint 早已考虑到了这一点，我们可以添加一个 npm 脚本用于全局修复格式错误。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint --fix src&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>npm run lint</code>，eslint 会尽可能修复格式错误，如果不能修复，会在控制台打印异常文件的路径，然后我们手动修复就好啦</p>
<h3 id="其他-rollup-配置"><a href="#其他-rollup-配置" class="headerlink" title="其他 rollup 配置"></a>其他 rollup 配置</h3><h4 id="添加代码映射文件"><a href="#添加代码映射文件" class="headerlink" title="添加代码映射文件"></a>添加代码映射文件</h4><p>其实很简单，只要在 <code>rollup.config.js</code> 启用一个配置就好了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 启用代码映射，便于调试之用</span></span><br><span class="line">    sourcemap: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多环境打包"><a href="#多环境打包" class="headerlink" title="多环境打包"></a>多环境打包</h4><p>首先移除掉根目录下的 <code>rollup.config.js</code> 配置文件，然后创建 build 目录并添加下面四个文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/util.js</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据相对路径计算真是的路径</span></span><br><span class="line"><span class="comment"> * 从当前类的文件夹开始计算，这里是 /build</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>relaPath 相对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;String&#125;</span> </span>绝对路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">calcPath</span>(<span class="params">relaPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.resolve(__dirname, relaPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/rollup.config.dev.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; eslint &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-eslint&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; calcPath &#125; <span class="keyword">from</span> <span class="string">&quot;./util&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&quot;../package.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  input: calcPath(<span class="string">&quot;../src/main.js&quot;</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 打包名称</span></span><br><span class="line">    name,</span><br><span class="line">    <span class="comment">// 打包的文件</span></span><br><span class="line">    file: calcPath(<span class="string">`../dist/<span class="subst">$&#123;name&#125;</span>.js`</span>),</span><br><span class="line">    <span class="comment">// 打包的格式，umd 支持 commonjs/amd/life 三种方式</span></span><br><span class="line">    format: <span class="string">&quot;umd&quot;</span>,</span><br><span class="line">    <span class="comment">// 启用代码映射，便于调试之用</span></span><br><span class="line">    sourcemap: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入 eslint 插件，必须在 babel 之前引入，因为 babel 编译之后的代码未必符合 eslint 规范，eslint 仅针对我们 [原本] 的代码</span></span><br><span class="line">    eslint(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/rollup.config.prod.js</span></span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-babel&quot;</span>;</span><br><span class="line"><span class="comment">// 注意，这里引入需要使用 &#123; uglify &#125; 而非 uglify，因为 uglify 导出自身时使用的是 exports.uglify</span></span><br><span class="line"><span class="keyword">import</span> &#123; uglify &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-uglify&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; eslint &#125; <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-eslint&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; calcPath &#125; <span class="keyword">from</span> <span class="string">&quot;./util&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> dev <span class="keyword">from</span> <span class="string">&quot;./rollup.config.dev&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&quot;../package.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  dev,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    input: calcPath(<span class="string">&quot;../src/main.js&quot;</span>),</span><br><span class="line">    output: &#123;</span><br><span class="line">      <span class="comment">// 打包名称</span></span><br><span class="line">      name,</span><br><span class="line">      <span class="comment">// 打包的文件</span></span><br><span class="line">      file: calcPath(<span class="string">`../dist/<span class="subst">$&#123;name&#125;</span>.min.js`</span>),</span><br><span class="line">      <span class="comment">// 打包的格式，umd 支持 commonjs/amd/life 三种方式</span></span><br><span class="line">      format: <span class="string">&quot;umd&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">// 引入 eslint 插件，必须在 babel 之前引入，因为 babel 编译之后的代码未必符合 eslint 规范，eslint 仅针对我们 [原本] 的代码</span></span><br><span class="line">      eslint(),</span><br><span class="line">      <span class="comment">// 引入 babel 插件</span></span><br><span class="line">      babel(&#123;</span><br><span class="line">        exclude: calcPath(<span class="string">&quot;../node_modules/**&quot;</span>),</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// js 压缩插件，需要在最后引入</span></span><br><span class="line">      uglify(),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> dev <span class="keyword">from</span> <span class="string">&quot;./rollup.config.dev&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> prod <span class="keyword">from</span> <span class="string">&quot;./rollup.config.prod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前环境时 production，则使用 prod 配置，否则使用 dev 配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? prod : dev;</span><br></pre></td></tr></table></figure>
<p>修改 npm 脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build:dev&quot;: &quot;rollup -c build/rollup.config.js --environment NODE_ENV:development&quot;,</span><br><span class="line">  &quot;build:prod&quot;: &quot;rollup -c build/rollup.config.js --environment NODE_ENV:production&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;npm run build:dev &amp;&amp; npm run build:prod&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>那么，关于使用 rollup 打包 JavaScript 的内容就先到这里了，有需要的话后续吾辈还会继续更新的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/bd842060067c45708d8c08f89c9fcf4c/" data-id="ckmcqox4n00830kuv5er7e8qs" data-title="使用 rollup 打包 JavaScript SDK" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-bf496d4b660f4226a03f2b8a04baee04" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/bf496d4b660f4226a03f2b8a04baee04/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/bf496d4b660f4226a03f2b8a04baee04/">react 入坑思考</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>吾辈为什么要学 <code>react</code> 呢？难道 <code>HTML+CSS+JavaScript</code> 已经满足不了了？是的，传统前端确实满足不了吾辈了，前端在快速发展，而后端手中（甚至眼中）的前端仍然是只有 <code>HTML+CSS+JavaScript+JQuery</code> 的世界。吾辈不想就这样下去，所以想要了解、学习、使用现代前端的内容。<br>谜之音：难道 <code>vuejs</code> 还不够么？<br><code>vuejs</code> 既是国产（阿里），所以文档（中文）相对而言应该是最好的。而且相比于 <code>react</code>，<code>vuejs</code> 的门槛相对而言还是比较低的。至少，不用一开始就接触 <code>webpack</code>（天坑），在不用 <code>webpack</code> 的情况下使用 <code>react</code> 将是很困难的。<br>或许有人说，<code>react</code> 不是有 <code>create-react-app</code> 可以快速创建 <code>web app</code> 么？然而使用 <code>create-react-app</code> 之后，一大波僵尸（概念）将会袭来。</p>
<h2 id="对白"><a href="#对白" class="headerlink" title="对白"></a>对白</h2><p>让我们先来看一段对白</p>
<p>问：<code>react</code> 好像不推荐在浏览器中直接使用 <code>&lt;script&gt;</code> 标签引入呢？<br>答：是呀，你需要 <code>npm/yarn</code> 这类工具呢<br>问：<code>npm</code> 是什么？<br>答：<code>npm</code> 能帮助我们管理依赖的库 只要 <code>install</code> 一下就可以啦<br>问：那么安装的包要怎么引用呢？<br>答：你需要用 <code>commonjs/es2016</code> 之类的方式引入呢？<br>问：等等，<code>commonjs</code>？<code>es2016</code>？这都是什么呀？<br>答：哦，这是一种 js 模块化的规范而已，我们只要知道 <code>import</code> 和 <code>export</code> 就好啦？<br>问：嗯，那么我应该在哪里写 <code>HTML</code>？<br>答：不不不，<code>react</code> 里面没有 <code>HTML</code>，只有 <code>jsx</code>。<br>问：OMG，<code>jsx</code> 又是什么？<br>答：一种 <code>js + xml</code> 的 <code>dsl</code>，语法上很像 <code>HTML</code>，no problem！<br>问：那写完的的 <code>jsx</code> 组件怎么在浏览器中查看啊？<br>答：你需要使用打包工具，例如 <code>webpack</code>，将 <code>jsx</code> 打包成 <code>HTML+JavaScript</code> 才行<br>问：额，不是没有 <code>HTML</code> 了么？<br>答：写的时候没有，但浏览器只认识 <code>HTML/CSS/JavaScript</code>，所以最终还是要变成这些才行呀<br>问：嗯，那么 <code>webpack</code> 是什么呢？<br>答：现代前端的一个打包工具<br>问：好的，那我去看看文档<br>一段时间后。。。<br>问：我看了 <code>webpack</code> 官网的文档，但还是不明白应该怎么打包<br>答：额，不行的话就用 <code>create-react-app</code> 吧。它会自动帮你生成一个完整配置的项目的，你只要懂得配置的意思并且会修改就好了。<br>问：于是，我开始了愉快的 <code>react</code> 之旅。。。个鬼呀！<strong>idea</strong> 怎么没提示？<br>答：额，你需要插件，不过更推荐 <strong>vscode</strong>，毕竟已经是事实上的前端标准编辑器了。<br>问：也就是说，我又要用一个新的 <code>IDE</code> 了？<br>答：不是啦，<strong>vscode</strong> 只是一个编辑器，比 <strong>idea</strong> 轻量太多了。而且，<strong>vscode</strong> 对前端生态支持很好哦<br>一段时间后。。。<br>问：我写了几个组件，但不知道应该怎么控制页面跳转？我好像并不能在后端映射到组件呀<br>答：<code>react</code> 需要使用 <code>react router</code> 之类的前端路由，现在前端的跳转由前端来控制就好了<br>问：所以说，不能使用 <code>java</code> 来控制么？≥﹏≤<br>答：额，可能真不行，为什么不用 <code>react router</code> 呢？<br>问：好吧，我先去看看。。。<br>问：唉，组件之间的交互好麻烦呀，每次都要依赖传递 <code>props</code> 啊<br>答：哦，你可以尝试一下状态管理。例如 <code>redux</code><br>问：<code>redux</code>？那是什么？<br>答：<code>react</code> 中的一个状态管理，可以不用一层层的传递 <code>props</code> 了呢<br>问：听起来很不错，我现在就去看一下！<br>问：两天后，woc，<code>redux</code> 去死吧？就想改个状态怎么这么麻烦，而且异步那里什么鬼？(ノ =Д=) ノ ┻━┻<br>答：看来你不适合 <code>react</code>，或许你可以看看 <code>vuejs</code>，更简单一点。国产，中文文档齐全，门槛很低的呢！</p>
<p>诚然，以上的问题不一定是指 <code>react</code> 本身，但依赖于如此之多的工具，本就造成了 <code>react</code> 的复杂性。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>看完以上对话，或许吾辈看起来很讨厌 <code>react</code> 的样子？<br>事实上，吾辈第一次学习现代前端的时候，就是从 <code>react</code> 开始的，然后基本上就像上面的对话所述，直接败退了，然后滚去学了一段时间的 <code>vuejs</code>。<br>然而，直到最近，吾辈发现 <code>vuejs</code> 的生态实在太小了。最开始吾辈就了解过这两个框架，也知道 <code>vuejs</code> 的生态很小，然而确实没想到会这么小。。。<br>深层次来讲，<code>vuejs</code> 毕竟是国产，毕竟是阿里，所以还是慎用。想想 <strong>Dubbo 放弃维护</strong> 和 <strong>Ant Design 圣诞彩蛋</strong>，一切皆是不言自明的！</p>
<p>现在再看 <code>react</code>，感觉简单了一些。一方面，由于 <code>vuejs</code> 的原因，接触到了 <code>es6/npm/yarn/webpack/babel/vscode</code> 这些前端工具链，对现代前端有了基本的概念与认知。不再因为某些代码看不懂而卡住，也不会面对各种工具一脸懵逼了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/bf496d4b660f4226a03f2b8a04baee04/" data-id="ckmcqox4p00890kuvg0zgf07z" data-title="react 入坑思考" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c2faf4d93d52495b90518b8a61d72f9e" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/02/c2faf4d93d52495b90518b8a61d72f9e/" class="article-date">
  <time class="dt-published" datetime="2020-02-02T02:15:37.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/02/c2faf4d93d52495b90518b8a61d72f9e/">vue 使用 git-rev-sync 确定线上发布版本号</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前公司仍然没有做 CI 持续集成，而是使用手动方式（脚本）部署项目。有时候，已经修改了代码，而线上（测试环境）却还没有部署，导致测试人员认为问题仍然没有修复。那么，怎么确定线上部署的代码版本呢？难道是打开线上网站查看某个功能是否完成了么？有没有更高效的方法呢？<br>吾辈找到的解决方案便是 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/git-rev-sync">git-rev-sync</a>。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官网描述只有一句话: 同步获取当前的 git commit 哈希，标签，计数，分支或提交消息。从 <a target="_blank" rel="noopener" href="https://github.com/tblobaum/git-rev">git-rev</a> 分叉。<br>实际上就是一个同步获取当前 git commit 最新提交的一些信息，而我们可以将它挂载到 <code>window</code> 对象上，方便线上快速确定发布代码的版本。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D git-rev-sync</span><br></pre></td></tr></table></figure>
<h3 id="在-vue-打包文件中读取-git-信息"><a href="#在-vue-打包文件中读取-git-信息" class="headerlink" title="在 vue 打包文件中读取 git 信息"></a>在 vue 打包文件中读取 git 信息</h3><p>只有在打包时我们才能读取到 git 信息（本地 nodejs 运行），而我们读取完之后不能直接挂载到 <code>window</code> 对象上，因为打包时处于 nodejs 环境，<code>window</code> 对象并不存在，这时候就需要用到 Vue 提供的环境变量功能了。</p>
<blockquote>
<p>引用<br><a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">Vue Cli 在客户端侧代码中使用环境变量</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> git = <span class="built_in">require</span>(<span class="string">&quot;git-rev-sync&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递打包时的环境变量到前端必须是以 VUE_APP_ 开头且必须只能是字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">process.env.VUE_APP_GIT = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  short: git.short(),</span><br><span class="line">  long: git.long(),</span><br><span class="line">  branch: git.branch(),</span><br><span class="line">  count: git.count(),</span><br><span class="line">  date: git.date(),</span><br><span class="line">  isDirty: git.isDirty(),</span><br><span class="line">  isTagDirty: git.isTagDirty(),</span><br><span class="line">  message: git.message(),</span><br><span class="line">  remoteUrl: git.remoteUrl(),</span><br><span class="line">  tag: git.tag(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="在-main-js-中读取环境变量并挂载到-window-对象上"><a href="#在-main-js-中读取环境变量并挂载到-window-对象上" class="headerlink" title="在 main.js 中读取环境变量并挂载到 window 对象上"></a>在 main.js 中读取环境变量并挂载到 window 对象上</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 window 对象上添加 git 属性便于查看指定版本</span></span><br><span class="line"><span class="built_in">window</span>.git = <span class="built_in">JSON</span>.parse(process.env.VUE_APP_GIT);</span><br></pre></td></tr></table></figure>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190927082613.png" alt="效果图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说到底需要这个工具的原因是因为部署的代码与最新的代码不一致，如果有了持续集成工具自动部署的话便不会存在这个问题了呢（这或许就是为什么该项目 <a target="_blank" rel="noopener" href="https://github.com/kurttheviking/git-rev-sync-js/stargazers">star</a> 这么少的原因？）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/02/c2faf4d93d52495b90518b8a61d72f9e/" data-id="ckmcqox4t008j0kuv0zj5cl6q" data-title="vue 使用 git-rev-sync 确定线上发布版本号" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/18/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/electron/" rel="tag">electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grid/" rel="tag">grid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jetbrains/" rel="tag">jetbrains</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vscode/" rel="tag">vscode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webstorm/" rel="tag">webstorm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA/" rel="tag">个人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AC%E5%8F%B8/" rel="tag">公司</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%A8%E6%8A%A5/" rel="tag">周报</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%A3%E5%91%8A/" rel="tag">宣告</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90/" rel="tag">开源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" rel="tag">待更新</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E9%AA%8C/" rel="tag">经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/css/" style="font-size: 12.14px;">css</a> <a href="/tags/electron/" style="font-size: 15.71px;">electron</a> <a href="/tags/git/" style="font-size: 12.86px;">git</a> <a href="/tags/grid/" style="font-size: 10.71px;">grid</a> <a href="/tags/java/" style="font-size: 19.29px;">java</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/jetbrains/" style="font-size: 12.14px;">jetbrains</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/markdown/" style="font-size: 10.71px;">markdown</a> <a href="/tags/react/" style="font-size: 14.29px;">react</a> <a href="/tags/sql/" style="font-size: 14.29px;">sql</a> <a href="/tags/typescript/" style="font-size: 12.14px;">typescript</a> <a href="/tags/vscode/" style="font-size: 12.86px;">vscode</a> <a href="/tags/vue/" style="font-size: 16.43px;">vue</a> <a href="/tags/webstorm/" style="font-size: 10px;">webstorm</a> <a href="/tags/windows/" style="font-size: 17.14px;">windows</a> <a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 12.86px;">个人</a> <a href="/tags/%E5%85%AC%E5%8F%B8/" style="font-size: 10px;">公司</a> <a href="/tags/%E5%91%A8%E6%8A%A5/" style="font-size: 10px;">周报</a> <a href="/tags/%E5%AE%A3%E5%91%8A/" style="font-size: 10px;">宣告</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.57px;">工具</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 17.86px;">工程化</a> <a href="/tags/%E5%BC%80%E6%BA%90/" style="font-size: 10px;">开源</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" style="font-size: 15px;">异步</a> <a href="/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/" style="font-size: 10.71px;">待更新</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 18.57px;">杂谈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 11.43px;">经验</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 12.14px;">读书</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 11.43px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/14/8fb2d58463ae4191ac064a76e15bffbd/">2021 第十周</a>
          </li>
        
          <li>
            <a href="/2021/03/12/7e7131c07c984d928ba3fefa7a9cef06/">读书-[颓废与沉默：透视犬儒文化]</a>
          </li>
        
          <li>
            <a href="/2021/03/02/db74e6e5d2444bc3b6e185a7b338bbf6/">electron 开发经验之谈系列-在渲染、主进程间共享数据</a>
          </li>
        
          <li>
            <a href="/2021/02/27/06cb464179cf45c598208534705aae3c/">2020 吾辈在公司推动的前端技术演进</a>
          </li>
        
          <li>
            <a href="/2021/02/23/cd66150d2b86448590fcc9bb2419c0b2/">实践 lerna monorepo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>